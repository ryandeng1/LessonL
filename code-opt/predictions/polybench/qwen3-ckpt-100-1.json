{
  "gemm": "\n\n```cpp\n#include <vector>\n\nvoid kernel_gemm(int ni, int nj, int nk,\n                 double alpha,\n                 double beta,\n                 std::vector<std::vector<double>>& A,\n                 std::vector<std::vector<double>>& B,\n                 std::vector<std::vector<double>>& C) {\n    for (int i = 0; i < ni; ++i) {\n        for (int j = 0; j < nj; ++j) {\n            C[i][j] *= beta;\n        }\n        for (int k = 0; k < nk; ++k) {\n            double a_ik = alpha * A[i][k];\n            for (int j = 0; j < nj; ++j) {\n                C[i][j] += a_ik * B[k][j];\n            }\n        }\n    }\n}\n```",
  "trisolv": "\n\n```cpp\nvoid kernel_trisolv(int n,\n                    std::vector<std::vector<double>>& L,\n                    std::vector<double>& x,\n                    std::vector<double>& b) {\n    for (int i = 0; i < n; ++i) {\n        double xi = b[i];\n        for (int j = 0; j < i; ++j) {\n            xi -= L[i][j] * x[j];\n        }\n        x[i] = xi / L[i][i];\n    }\n}\n```",
  "atax": "\n\n```cpp\n#include <vector>\n\nvoid kernel_atax(int m, int n,\n                 std::vector<std::vector<double>>& A,\n                 std::vector<double>& x,\n                 std::vector<double>& y,\n                 std::vector<double>& tmp) {\n    for (int i = 0; i < n; ++i) {\n        y[i] = 0.0;\n    }\n    #pragma omp parallel for\n    for (int i = 0; i < m; ++i) {\n        double t = 0.0;\n        for (int j = 0; j < n; ++j) {\n            t += A[i][j] * x[j];\n        }\n        for (int j = 0; j < n; ++j) {\n            y[j] += t * A[i][j];\n        }\n    }\n}\n```",
  "syr2k": "\n\n```cpp\nvoid kernel_syr2k(int n, int m, double alpha, double beta, std::vector<std::vector<double>>& C, std::vector<std::vector<double>>& A, std::vector<std::vector<double>>& B) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j <= i; ++j) {\n            C[i][j] *= beta;\n        }\n        for (int k = 0; k < m; ++k) {\n            const double b = B[i][k];\n            const double a = A[i][k];\n            const double ab = alpha * b;\n            const double aa = alpha * a;\n            for (int j = 0; j <= i; ++j) {\n                C[i][j] += ab * A[j][k] + aa * B[j][k];\n            }\n        }\n    }\n}\n```",
  "gesummv": "\n\n```cpp\nvoid kernel_gesummv(int n,\n                    double alpha,\n                    double beta,\n                    std::vector<std::vector<double>>& A,\n                    std::vector<std::vector<double>>& B,\n                    std::vector<double>& tmp,\n                    std::vector<double>& x,\n                    std::vector<double>& y) {\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        double s1 = 0.0;\n        double s2 = 0.0;\n        for (int j = 0; j < n; ++j) {\n            s1 += A[i][j] * x[j];\n            s2 += B[i][j] * x[j];\n        }\n        y[i] = alpha * s1 + beta * s2;\n        tmp[i] = s1;\n    }\n}\n```",
  "nussinov": "\n\n```cpp\n#include <vector>\n#include <algorithm>\n\nvoid kernel_nussinov(int n, std::vector<int>& seq, std::vector<std::vector<int>>& table) {\n    for (int i = n - 1; i >= 0; --i) {\n        for (int j = i + 1; j < n; ++j) {\n            table[i][j] = std::max(table[i][j], table[i][j-1]);\n            table[i][j] = std::max(table[i][j], table[i+1][j]);\n            if (i < j - 1) {\n                table[i][j] = std::max(table[i][j], table[i+1][j-1] + (seq[i] + seq[j] == 3));\n            } else {\n                table[i][j] = std::max(table[i][j], table[i+1][j-1]);\n            }\n            int best = table[i][j];\n            for (int k = i + 1; k < j; ++k) {\n                int candidate = table[i][k] + table[k+1][j];\n                if (candidate > best) {\n                    best = candidate;\n                }\n            }\n            table[i][j] = best;\n        }\n    }\n}\n```",
  "durbin": "\n\n```cpp\n#include <vector>\n\nvoid kernel_durbin(int n,\n                   std::vector<double>& r,\n                   std::vector<double>& y) {\n    std::vector<double> z(n);\n    y[0] = -r[0];\n    double beta = 1.0;\n    double alpha = -r[0];\n    for (int k = 1; k < n; ++k) {\n        double alpha_sq = alpha * alpha;\n        beta = (1.0 - alpha_sq) * beta;\n        double sum = 0.0;\n        for (int i = 0; i < k; i += 4) {\n            sum += r[k - 1 - i] * y[i];\n            if (i + 1 < k) sum += r[k - 1 - (i + 1)] * y[i + 1];\n            if (i + 2 < k) sum += r[k - 1 - (i + 2)] * y[i + 2];\n            if (i + 3 < k) sum += r[k - 1 - (i + 3)] * y[i + 3];\n        }\n        alpha = -(r[k] + sum) / beta;\n        for (int i = 0; i < k; i += 2) {\n            int j = k - 1 - i;\n            z[i] = y[i] + alpha * y[j];\n            if (i != j) {\n                z[j] = y[j] + alpha * y[i];\n            }\n        }\n        for (int i = 0; i < k; ++i) {\n            y[i] = z[i];\n        }\n        y[k] = alpha;\n    }\n}\n```",
  "doitgen": "\n\n```cpp\n#include <vector>\n\nvoid kernel_doitgen(int nr, int nq, int np,\n                    std::vector<std::vector<std::vector<double>>>& A,\n                    std::vector<std::vector<double>>& C4,\n                    std::vector<double>& sum) {\n    for (int r = 0; r < nr; ++r) {\n        for (int q = 0; q < nq; ++q) {\n            for (int p = 0; p < np; ++p) {\n                sum[p] = 0.0;\n            }\n            for (int s = 0; s < np; ++s) {\n                double val = A[r][q][s];\n                for (int p = 0; p < np; ++p) {\n                    sum[p] += val * C4[s][p];\n                }\n            }\n            for (int p = 0; p < np; ++p) {\n                A[r][q][p] = sum[p];\n            }\n        }\n    }\n}\n```",
  "adi": "\n\n```cpp\n#include <vector>\n#include <omp.h>\n\nvoid kernel_adi(int tsteps, int n,\n        std::vector<std::vector<double>>& u,\n        std::vector<std::vector<double>>& v,\n        std::vector<std::vector<double>>& p,\n        std::vector<std::vector<double>>& q) {\n    double DX = 1.0 / n;\n    double DY = 1.0 / n;\n    double DT = 1.0 / tsteps;\n    double B1 = 2.0;\n    double B2 = 1.0;\n    double mul1 = B1 * DT / (DX * DX);\n    double mul2 = B2 * DT / (DY * DY);\n    double a = -mul1 / 2.0;\n    double b = 1.0 + mul1;\n    double c = a;\n    double d = -mul2 / 2.0;\n    double e = 1.0 + mul2;\n    double f = d;\n\n    #pragma omp parallel for\n    for (int t = 1; t <= tsteps; ++t) {\n        for (int i = 1; i < n - 1; ++i) {\n            v[0][i] = 1.0;\n            p[i][0] = 0.0;\n            q[i][0] = v[0][i];\n            for (int j = 1; j < n - 1; ++j) {\n                double denom = a * p[i][j-1] + b;\n                p[i][j] = -a / denom;\n                double num = (1.0 + 2.0 * d) * u[j][i] - d * (u[j][i-1] + u[j][i+1]) - a * q[i][j-1];\n                q[i][j] = num / denom;\n            }\n            v[n-1][i] = 1.0;\n            for (int j = n - 2; j >= 1; --j) {\n                v[j][i] = p[i][j] * v[j+1][i] + q[i][j];\n            }\n        }\n\n        for (int i = 1; i < n - 1; ++i) {\n            u[i][0] = 1.0;\n            p[i][0] = 0.0;\n            q[i][0] = u[i][0];\n            for (int j = 1; j < n - 1; ++j) {\n                double denom = d * p[i][j-1] + e;\n                p[i][j] = -d / denom;\n                double num = (1.0 + 2.0 * a) * v[i][j] - a * (v[i-1][j] + v[i+1][j]) - d * q[i][j-1];\n                q[i][j] = num / denom;\n            }\n            u[i][n-1] = 1.0;\n            for (int j = n - 2; j >= 1; --j) {\n                u[i][j] = p[i][j] * u[i][j+1] + q[i][j];\n            }\n        }\n    }\n}\n```",
  "syrk": "\n\n```cpp\n#include <vector>\nvoid kernel_syrk(int n, int m,\n                 double alpha,\n                 double beta,\n                 std::vector<std::vector<double>>& C,\n                 std::vector<std::vector<double>>& A) {\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j <= i; ++j) {\n            C[i][j] *= beta;\n        }\n        for (int j = 0; j <= i; ++j) {\n            double accum = 0.0;\n            for (int k = 0; k < m; ++k) {\n                double temp = alpha * A[i][k];\n                accum += temp * A[j][k];\n            }\n            C[i][j] += accum;\n        }\n    }\n}\n```",
  "bicg": "\n\n```cpp\n#include <vector>\n\nvoid kernel_bicg(int m, int n,\n                 std::vector<std::vector<double>>& A,\n                 std::vector<double>& s,\n                 std::vector<double>& q,\n                 std::vector<double>& p,\n                 std::vector<double>& r) {\n    for (int i = 0; i < m; ++i) {\n        s[i] = 0.0;\n    }\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        double r_i = r[i];\n        double q_i = 0.0;\n        for (int j = 0; j < m; ++j) {\n            s[j] += r_i * A[i][j];\n            q_i += A[i][j] + p[j];\n        }\n        q[i] = q_i;\n    }\n}\n```",
  "covariance": "\n\n```cpp\n#include <vector>\n\nvoid kernel_covariance(int m, int n, \n                       std::vector<std::vector<double>>& data,\n                       std::vector<std::vector<double>>& cov,\n                       std::vector<double>& mean) {\n    for (int j = 0; j < m; ++j) {\n        double sum = 0.0;\n        for (int i = 0; i < n; ++i) {\n            sum += data[i][j];\n        }\n        mean[j] = sum / n;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            data[i][j] -= mean[j];\n        }\n    }\n\n    const double inv_n_minus_one = 1.0 / (n - 1.0);\n    for (int i = 0; i < m; ++i) {\n        for (int j = i + 1; j < m; ++j) {\n            double sum = 0.0;\n            #pragma omp parallel for\n            for (int k = 0; k < n; ++k) {\n                sum += data[k][i] * data[k][j];\n            }\n            cov[i][j] = sum * inv_n_minus_one;\n            cov[j][i] = cov[i][j];\n        }\n    }\n}\n```",
  "3mm": "\n\n```cpp\n#include <vector>\n\nvoid kernel_3mm(int ni, int nj, int nk, int nl, int nm,\n        std::vector<std::vector<double>>& E,\n        std::vector<std::vector<double>>& A,\n        std::vector<std::vector<double>>& B,\n        std::vector<std::vector<double>>& F,\n        std::vector<std::vector<double>>& C,\n        std::vector<std::vector<double>>& D,\n        std::vector<std::vector<double>>& G) {\n\n    for (int i = 0; i < ni; ++i) {\n        for (int j = 0; j < nj; ++j) {\n            double sum = 0.0;\n            #pragma omp parallel for reduction(+:sum)\n            for (int k = 0; k < nk; ++k) {\n                sum += A[i][k] * B[k][j];\n            }\n            E[i][j] = sum;\n        }\n    }\n\n    for (int i = 0; i < nj; ++i) {\n        for (int j = 0; j < nl; ++j) {\n            double sum = 0.0;\n            #pragma omp parallel for reduction(+:sum)\n            for (int k = 0; k < nm; ++k) {\n                sum += C[i][k] * D[k][j];\n            }\n            F[i][j] = sum;\n        }\n    }\n\n    for (int i = 0; i < ni; ++i) {\n        for (int j = 0; j < nl; ++j) {\n            double sum = 0.0;\n            #pragma omp parallel for reduction(+:sum)\n            for (int k = 0; k < nj; ++k) {\n                sum += E[i][k] * F[k][j];\n            }\n            G[i][j] = sum;\n        }\n    }\n}\n```",
  "heat_3d": "\n\n```cpp\n#include <vector>\n\nvoid kernel_heat_3d(int tsteps, int n, std::vector<std::vector<std::vector<double>>>& A, std::vector<std::vector<std::vector<double>>>& B) {\n    for (int t = 1; t <= tsteps; ++t) {\n        for (int i = 1; i < n - 1; ++i) {\n            for (int j = 1; j < n - 1; ++j) {\n                for (int k = 1; k < n - 1; ++k) {\n                    double a = A[i][j][k];\n                    double sum = A[i-1][j][k] + A[i+1][j][k] + A[i][j-1][k] + A[i][j+1][k] + A[i][j][k-1] + A[i][j][k+1];\n                    B[i][j][k] = (sum + 4.0 * a) * 0.125;\n                }\n            }\n        }\n        for (int i = 1; i < n - 1; ++i) {\n            for (int j = 1; j < n - 1; ++j) {\n                for (int k = 1; k < n - 1; ++k) {\n                    double b = B[i][j][k];\n                    double sum = B[i-1][j][k] + B[i+1][j][k] + B[i][j-1][k] + B[i][j+1][k] + B[i][j][k-1] + B[i][j][k+1];\n                    A[i][j][k] = (sum + 4.0 * b) * 0.125;\n                }\n            }\n        }\n    }\n}\n```",
  "symm": "\n\n```cpp\n#include <vector>\n\nvoid kernel_symm(int m, int n,\n                 double alpha,\n                 double beta,\n                 std::vector<std::vector<double>>& C,\n                 std::vector<std::vector<double>>& A,\n                 std::vector<std::vector<double>>& B) {\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            double alpha_b_ij = alpha * B[i][j];\n            double temp2 = 0.0;\n            for (int k = 0; k < i; k += 4) {\n                C[k][j] += alpha_b_ij * A[i][k];\n                C[k+1][j] += alpha_b_ij * A[i][k+1];\n                C[k+2][j] += alpha_b_ij * A[i][k+2];\n                C[k+3][j] += alpha_b_ij * A[i][k+3];\n                temp2 += B[k][j] * A[i][k];\n                temp2 += B[k+1][j] * A[i][k+1];\n                temp2 += B[k+2][j] * A[i][k+2];\n                temp2 += B[k+3][j] * A[i][k+3];\n            }\n            for (int k = i - (i % 4); k < i; ++k) {\n                C[k][j] += alpha_b_ij * A[i][k];\n                temp2 += B[k][j] * A[i][k];\n            }\n            C[i][j] = beta * C[i][j] + alpha * B[i][j] * A[i][i] + alpha * temp2;\n        }\n    }\n}\n```",
  "correlation": "\n\n```cpp\n#include <cmath>\n#include <vector>\n\nvoid kernel_correlation(int m, int n,\n        std::vector<std::vector<double>>& data,\n        std::vector<std::vector<double>>& corr,\n        std::vector<double>& mean,\n        std::vector<double>& stddev) {\n    double eps = 0.1;\n    for (int j = 0; j < m; ++j) {\n        mean[j] = 0.0;\n        #pragma omp parallel for reduction(+:mean[j])\n        for (int i = 0; i < n; ++i) {\n            mean[j] += data[i][j];\n        }\n        mean[j] /= n;\n    }\n\n    for (int j = 0; j < m; ++j) {\n        double sum_sq = 0.0;\n        #pragma omp parallel for reduction(+:sum_sq)\n        for (int i = 0; i < n; ++i) {\n            double diff = data[i][j] - mean[j];\n            sum_sq += diff * diff;\n        }\n        stddev[j] = std::sqrt(sum_sq / n);\n        stddev[j] = (stddev[j] <= eps) ? 1.0 : stddev[j];\n    }\n\n    double inv_scale = 1.0 / std::sqrt(n);\n    std::vector<double> inv_stddev(m);\n    for (int j = 0; j < m; ++j) {\n        inv_stddev[j] = 1.0 / stddev[j];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        #pragma omp parallel for\n        for (int j = 0; j < m; ++j) {\n            data[i][j] -= mean[j];\n            data[i][j] *= inv_scale * inv_stddev[j];\n        }\n    }\n\n    for (int i = 0; i < m - 1; ++i) {\n        corr[i][i] = 1.0;\n        for (int j = i + 1; j < m; ++j) {\n            double sum = 0.0;\n            #pragma omp parallel for reduction(+:sum)\n            for (int k = 0; k < n; ++k) {\n                sum += data[k][i] * data[k][j];\n            }\n            corr[i][j] = sum;\n            corr[j][i] = sum;\n        }\n    }\n    corr[m-1][m-1] = 1.0;\n}\n```",
  "mvt": "\n\n```cpp\n#include <vector>\n\nvoid kernel_mvt(int n,\n        std::vector<double>& x1,\n        std::vector<double>& x2,\n        std::vector<double>& y_1,\n        std::vector<double>& y_2,\n        std::vector<std::vector<double>>& A) {\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            x1[i] += A[i][j] * y_1[j];\n        }\n    }\n    #pragma omp parallel for\n    for (int j = 0; j < n; ++j) {\n        double y2j = y_2[j];\n        for (int i = 0; i < n; ++i) {\n            x2[i] += A[j][i] * y2j;\n        }\n    }\n}\n```",
  "gramschmidt": "\n\n```cpp\n#include <cmath>\n#include <vector>\n\nvoid kernel_gramschmidt(int m, int n,\n                        std::vector<std::vector<double>>& A,\n                        std::vector<std::vector<double>>& R,\n                        std::vector<std::vector<double>>& Q) {\n    for (int k = 0; k < n; ++k) {\n        double nrm = 0.0;\n        for (int i = 0; i < m; ++i) {\n            nrm += A[i][k] * A[i][k];\n        }\n        R[k][k] = std::sqrt(nrm);\n        double inv_r = 1.0 / R[k][k];\n        for (int i = 0; i < m; ++i) {\n            Q[i][k] = A[i][k] * inv_r;\n        }\n        for (int j = k + 1; j < n; ++j) {\n            double r = 0.0;\n            for (int i = 0; i < m; ++i) {\n                r += Q[i][k] * A[i][j];\n            }\n            for (int i = 0; i < m; ++i) {\n                A[i][j] -= r * Q[i][k];\n            }\n        }\n    }\n}\n```",
  "2mm": "\n\n```cpp\n#include <vector>\n#include <omp.h>\n\nvoid kernel_2mm(int ni, int nj, int nk, int nl,\n        double alpha,\n        double beta,\n        std::vector<std::vector<double>>& tmp,\n        std::vector<std::vector<double>>& A,\n        std::vector<std::vector<double>>& B,\n        std::vector<std::vector<double>>& C,\n        std::vector<std::vector<double>>& D) {\n    for (int i = 0; i < ni; ++i) {\n        for (int j = 0; j < nj; ++j) {\n            tmp[i][j] = 0.0;\n            #pragma omp parallel for\n            for (int k = 0; k < nk; ++k) {\n                tmp[i][j] += alpha * A[i][k] * B[k][j];\n            }\n        }\n    }\n    for (int i = 0; i < ni; ++i) {\n        for (int j = 0; j < nl; ++j) {\n            D[i][j] *= beta;\n            #pragma omp parallel for\n            for (int k = 0; k < nj; ++k) {\n                D[i][j] += tmp[i][k] * C[k][j];\n            }\n        }\n    }\n}\n```",
  "floyd_warshall": "\n\n```cpp\n#include <vector>\n\nvoid kernel_floyd_warshall(int n, std::vector<std::vector<int>>& path) {\n    for (int k = 0; k < n; ++k) {\n        for (int i = 0; i < n; ++i) {\n            int ik = path[i][k];\n            for (int j = 0; j < n; ++j) {\n                int candidate = ik + path[k][j];\n                if (candidate < path[i][j]) {\n                    path[i][j] = candidate;\n                }\n            }\n        }\n    }\n}\n```",
  "jacobi_1d": "\n\n```cpp\n#include <vector>\n\nvoid kernel_jacobi_1d(int tsteps,\n                      int n,\n                      std::vector<double>& A,\n                      std::vector<double>& B) {\n    const double inv3 = 0.33333;\n    for (int t = 0; t < tsteps; ++t) {\n        for (int i = 1; i < n - 1; i += 2) {\n            B[i] = inv3 * (A[i-1] + A[i] + A[i+1]);\n            if (i + 1 < n - 1) {\n                B[i+1] = inv3 * (A[i] + A[i+1] + A[i+2]);\n            }\n        }\n        for (int i = 1; i < n - 1; i += 2) {\n            A[i] = inv3 * (B[i-1] + B[i] + B[i+1]);\n            if (i + 1 < n - 1) {\n                A[i+1] = inv3 * (B[i] + B[i+1] + B[i+2]);\n            }\n        }\n    }\n}\n```",
  "gemver": "\n\n```cpp\n#include <vector>\n\nvoid kernel_gemver(int n,\n                   double alpha,\n                   double beta,\n                   std::vector<std::vector<double>>& A,\n                   std::vector<double>& u1,\n                   std::vector<double>& v1,\n                   std::vector<double>& u2,\n                   std::vector<double>& v2,\n                   std::vector<double>& w,\n                   std::vector<double>& x,\n                   std::vector<double>& y,\n                   std::vector<double>& z) {\n    for (int i = 0; i < n; ++i) {\n        double s1 = u1[i];\n        double s2 = u2[i];\n        for (int j = 0; j < n; ++j) {\n            A[i][j] += s1 * v1[j] + s2 * v2[j];\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        double b = beta;\n        for (int j = 0; j < n; ++j) {\n            x[i] += b * A[j][i] * y[j];\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        x[i] += z[i];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        double a = alpha;\n        for (int j = 0; j < n; ++j) {\n            w[i] += a * A[i][j] * x[j];\n        }\n    }\n}\n```",
  "fdtd_2d": "\n\n```cpp\n#include <vector>\n\nvoid kernel_fdtd_2d(int tmax,\n                    int nx,\n                    int ny,\n                    std::vector<std::vector<double>>& ex,\n                    std::vector<std::vector<double>>& ey,\n                    std::vector<std::vector<double>>& hz,\n                    std::vector<double>& _fict_) {\n    for (int t = 0; t < tmax; ++t) {\n        double fict = _fict_[t];\n        #pragma omp parallel for\n        for (int j = 0; j < ny; ++j) {\n            ey[0][j] = fict;\n        }\n        for (int i = 1; i < nx; ++i) {\n            for (int j = 0; j < ny; ++j) {\n                ey[i][j] -= 0.5 * (hz[i][j] - hz[i-1][j]);\n            }\n        }\n        for (int i = 0; i < nx; ++i) {\n            for (int j = 1; j < ny; ++j) {\n                ex[i][j] -= 0.5 * (hz[i][j] - hz[i][j-1]);\n            }\n        }\n        for (int i = 0; i < nx - 1; ++i) {\n            for (int j = 0; j < ny - 1; ++j) {\n                double ex_diff = ex[i][j+1] - ex[i][j];\n                double ey_diff = ey[i+1][j] - ey[i][j];\n                hz[i][j] -= 0.7 * (ex_diff + ey_diff);\n            }\n        }\n    }\n}\n```",
  "trmm": "\n\n```cpp\nvoid kernel_trmm(int m, int n,\n                 double alpha,\n                 std::vector<std::vector<double>>& A,\n                 std::vector<std::vector<double>>& B) {\n    for (int i = 0; i < m; ++i) {\n        for (int k = i + 1; k < m; ++k) {\n            double factor = A[k][i];\n            for (int j = 0; j < n; ++j) {\n                B[i][j] += factor * B[k][j];\n            }\n        }\n        for (int j = 0; j < n; ++j) {\n            B[i][j] *= alpha;\n        }\n    }\n}\n```",
  "jacobi_2d": "\n\n```cpp\n#include <vector>\n\nvoid kernel_jacobi_2d(int tsteps,\n                      int n,\n                      std::vector<std::vector<double>>& A,\n                      std::vector<std::vector<double>>& B) {\n    for (int t = 0; t < tsteps; ++t) {\n        #pragma omp parallel for\n        for (int i = 1; i < n - 1; ++i) {\n            double* a_prev = A[i-1].data();\n            double* a_curr = A[i].data();\n            double* a_next = A[i+1].data();\n            double* b_curr = B[i].data();\n            for (int j = 1; j < n - 1; ++j) {\n                double s = a_curr[j] + a_curr[j-1] + a_curr[j+1] + a_prev[j] + a_next[j];\n                b_curr[j] = 0.2 * s;\n            }\n        }\n        #pragma omp parallel for\n        for (int i = 1; i < n - 1; ++i) {\n            double* b_prev = B[i-1].data();\n            double* b_curr = B[i].data();\n            double* b_next = B[i+1].data();\n            double* a_curr = A[i].data();\n            for (int j = 1; j < n - 1; ++j) {\n                double s = b_curr[j] + b_curr[j-1] + b_curr[j+1] + b_prev[j] + b_next[j];\n                a_curr[j] = 0.2 * s;\n            }\n        }\n    }\n}\n```",
  "ludcmp": "\n\n```cpp\n#include <vector>\n\nvoid kernel_ludcmp(int n,\n                   std::vector<std::vector<double>>& A,\n                   std::vector<double>& b,\n                   std::vector<double>& x,\n                   std::vector<double>& y) {\n    for (int i = 0; i < n; ++i) {\n        for (int k = 0; k < i; ++k) {\n            double a_ik = A[i][k];\n            for (int j = k + 1; j < i; ++j) {\n                A[i][j] -= a_ik * A[k][j];\n            }\n        }\n        for (int j = 0; j < i; ++j) {\n            A[i][j] /= A[j][j];\n        }\n        for (int k = 0; k < i; ++k) {\n            double a_ik = A[i][k];\n            for (int j = i; j < n; ++j) {\n                A[i][j] -= a_ik * A[k][j];\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        double w = b[i];\n        for (int j = 0; j < i; ++j) {\n            w -= A[i][j] * y[j];\n        }\n        y[i] = w;\n    }\n    for (int i = n - 1; i >= 0; --i) {\n        double w = y[i];\n        for (int j = i + 1; j < n; ++j) {\n            w -= A[i][j] * x[j];\n        }\n        x[i] = w / A[i][i];\n    }\n}\n```",
  "seidel_2d": "\n\n```cpp\n#include <vector>\n\nvoid kernel_seidel_2d(int tsteps, int n, std::vector<std::vector<double>>& A) {\n    const double inv9 = 1.0 / 9.0;\n    for (int t = 0; t < tsteps; ++t) {\n        #pragma omp parallel for\n        for (int i = 1; i < n - 1; ++i) {\n            double* prev = &A[i-1][0];\n            double* curr = &A[i][0];\n            double* next = &A[i+1][0];\n            #pragma omp parallel for\n            for (int j = 0; j < n - 2; ++j) {\n                double sum = prev[j] + prev[j+1] + prev[j+2] +\n                             curr[j] + curr[j+1] + curr[j+2] +\n                             next[j] + next[j+1] + next[j+2];\n                curr[j+1] = sum * inv9;\n            }\n        }\n    }\n}\n```",
  "deriche": "\n\n```cpp\n#include <cmath>\n#include <vector>\n#include <omp.h>\n\nvoid kernel_deriche(int w, int h, double alpha,\n                    std::vector<std::vector<float>>& imgIn,\n                    std::vector<std::vector<float>>& imgOut,\n                    std::vector<std::vector<float>>& y1,\n                    std::vector<std::vector<float>>& y2) {\n    float exp_alpha = static_cast<float>(std::exp(-alpha));\n    float exp_alpha_sq = exp_alpha * exp_alpha;\n    float k = 1.0f - (exp_alpha * (1.0f - exp_alpha)) / (1.0f + 2.0f * alpha * exp_alpha - exp_alpha_sq);\n    float a1 = k;\n    float a2 = k * exp_alpha * (alpha - 1.0f);\n    float a3 = k * exp_alpha * (alpha + 1.0f);\n    float a4 = -k * exp_alpha_sq;\n    float a5 = a1;\n    float a6 = a2;\n    float a7 = a3;\n    float a8 = a4;\n    float b1 = static_cast<float>(std::pow(2.0f, -alpha));\n    float b2 = -exp_alpha_sq;\n    float c1 = 1.0f;\n    float c2 = 1.0f;\n\n    #pragma omp parallel for\n    for (int i = 0; i < w; ++i) {\n        float ym1 = 0.0f;\n        float ym2 = 0.0f;\n        float xm1 = 0.0f;\n        for (int j = 0; j < h; ++j) {\n            y1[i][j] = a1 * imgIn[i][j] + a2 * xm1 + b1 * ym1 + b2 * ym2;\n            xm1 = imgIn[i][j];\n            ym2 = ym1;\n            ym1 = y1[i][j];\n        }\n    }\n\n    #pragma omp parallel for\n    for (int i = 0; i < w; ++i) {\n        float yp1 = 0.0f;\n        float yp2 = 0.0f;\n        float xp1 = 0.0f;\n        float xp2 = 0.0f;\n        for (int j = h - 1; j >= 0; --j) {\n            y2[i][j] = a3 * xp1 + a4 * xp2 + b1 * yp1 + b2 * yp2;\n            xp2 = xp1;\n            xp1 = imgIn[i][j];\n            yp2 = yp1;\n            yp1 = y2[i][j];\n        }\n    }\n\n    for (int i = 0; i < w; ++i) {\n        for (int j = 0; j < h; ++j) {\n            imgOut[i][j] = c1 * (y1[i][j] + y2[i][j]);\n        }\n    }\n\n    #pragma omp parallel for\n    for (int j = 0; j < h; ++j) {\n        float tm1 = 0.0f;\n        float ym1 = 0.0f;\n        float ym2 = 0.0f;\n        for (int i = 0; i < w; ++i) {\n            y1[i][j] = a5 * imgOut[i][j] + a6 * tm1 + b1 * ym1 + b2 * ym2;\n            tm1 = imgOut[i][j];\n            ym2 = ym1;\n            ym1 = y1[i][j];\n        }\n    }\n\n    #pragma omp parallel for\n    for (int j = 0; j < h; ++j) {\n        float tp1 = 0.0f;\n        float tp2 = 0.0f;\n        float yp1 = 0.0f;\n        float yp2 = 0.0f;\n        for (int i = w - 1; i >= 0; --i) {\n            y2[i][j] = a7 * tp1 + a8 * tp2 + b1 * yp1 + b2 * yp2;\n            tp2 = tp1;\n            tp1 = imgOut[i][j];\n            yp2 = yp1;\n            yp1 = y2[i][j];\n        }\n    }\n\n    for (int i = 0; i < w; ++i) {\n        for (int j = 0; j < h; ++j) {\n            imgOut[i][j] = c2 * (y1[i][j] + y2[i][j]);\n        }\n    }\n}\n```",
  "cholesky": "\n\n```cpp\n#include <cmath>\n#include <vector>\n\nvoid kernel_cholesky(int n,\n                     std::vector<std::vector<double>>& A) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            double sum = 0.0;\n            for (int k = 0; k < j; ++k) {\n                sum -= A[i][k] * A[j][k];\n            }\n            A[i][j] = sum / A[j][j];\n        }\n        double sum_sq = 0.0;\n        for (int k = 0; k < i; ++k) {\n            sum_sq += A[i][k] * A[i][k];\n        }\n        A[i][i] = std::sqrt(A[i][i] - sum_sq);\n    }\n}\n```",
  "lu": "\n\n```cpp\n#include <vector>\n\nvoid kernel_lu(int n,\n               std::vector<std::vector<double>>& A) {\n    for (int j = 0; j < n; ++j) {\n        double inv_jj = 1.0 / A[j][j];\n        for (int i = j + 1; i < n; ++i) {\n            double temp = A[i][j];\n            for (int k = 0; k < j; ++k) {\n                temp -= A[i][k] * A[k][j];\n            }\n            A[i][j] = temp * inv_jj;\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            double temp = A[i][j];\n            for (int k = 0; k < i; ++k) {\n                temp -= A[i][k] * A[k][j];\n            }\n            A[i][j] = temp;\n        }\n    }\n}\n```"
}