{
  "33_scan_reverse_prefix_sum": "\n\n```cpp\n#include <algorithm>\n#include <numeric>\n#include <vector>\n\nvoid reversePrefixSum(std::vector<int> const& x, std::vector<int> &output) {\n    const int n = x.size();\n    std::vector<int> reverseX(n);\n    std::reverse_copy(x.rbegin(), x.rend(), reverseX.begin());\n    std::inclusive_scan(reverseX.begin(), reverseX.end(), output.begin());\n}\n```",
  "59_transform_map_function": "\n\n```cpp\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); ++i) {\n        mask[i] = isPowerOfTwo(x[i]);\n    }\n}\n```",
  "30_scan_prefix_sum": "\n\n```cpp\nvoid prefixSum(std::vector<int64_t> const& x, std::vector<int64_t> &output) {\n    std::inclusive_scan(x.begin(), x.end(), output.begin());\n}\n```",
  "31_scan_scan_with_min_function": "\n\n```cpp\nvoid partialMinimums(std::vector<float> &x) {\n    for (size_t i = 1; i < x.size(); ++i) {\n        x[i] = x[i] < x[i-1] ? x[i] : x[i-1];\n    }\n}\n```",
  "21_histogram_bin_0-100": "\n\n```cpp\nvoid binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {\n    for (size_t i = 0; i < x.size(); ++i) {\n        size_t bin = static_cast<int>(x[i]) / 10;\n        bins[bin]++;\n    }\n}\n```",
  "32_scan_sum_of_prefix_sum_array": "\n\n```cpp\nint64_t sumOfPrefixSum(std::vector<int64_t> const& x) {\n    int64_t n = x.size();\n    int64_t total = 0;\n    for (int i = 0; i < n; ++i) {\n        total += x[i] * (n - i);\n    }\n    return total;\n}\n```",
  "23_histogram_first_letter_counts": "\n\n```cpp\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {\n    #pragma omp parallel for\n    for (int i = 0; i < s.size(); ++i) {\n        const char c = s[i][0];\n        const int index = c - 'a';\n        #pragma omp atomic\n            bins[index]++;\n    }\n}\n```",
  "18_graph_count_components": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <stack>\n\nvoid dfs_helper(std::vector<int> const& A, int node, size_t N, std::vector<bool> &visited) {\n    std::stack<int> st;\n    st.push(node);\n    visited[node] = true;\n    while (!st.empty()) {\n        int cur = st.top();\n        st.pop();\n        int row = cur * N;\n        for (int i = 0; i < N; ++i) {\n            if (A[row + i] && !visited[i]) {\n                visited[i] = true;\n                st.push(i);\n            }\n        }\n    }\n}\n\nint componentCount(std::vector<int> const& A, size_t N) {\n    std::vector<bool> visited(N, false);\n    int count = 0;\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            dfs_helper(A, i, N, visited);\n            ++count;\n        }\n    }\n    return count;\n}\n```",
  "20_histogram_pixel_histogram": "\n\n```cpp\nvoid pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {\n    for (int i = 0; i < image.size(); ++i) {\n        ++bins[image[i]];\n    }\n}\n```",
  "16_graph_largest_component": "\n\n```cpp\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nint largestComponent(std::vector<int> const& A, size_t N) {\n    std::vector<std::vector<int>> adj(N);\n    for (int node = 0; node < N; ++node) {\n        for (int i = 0; i < N; ++i) {\n            if (A[node * N + i] == 1) {\n                adj[node].push_back(i);\n            }\n        }\n    }\n    std::vector<bool> visited(N, false);\n    int maxCount = 0;\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            int count = 0;\n            std::stack<int> stack;\n            stack.push(i);\n            visited[i] = true;\n            ++count;\n            while (!stack.empty()) {\n                int current = stack.top();\n                stack.pop();\n                for (int neighbor : adj[current]) {\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        ++count;\n                        stack.push(neighbor);\n                    }\n                }\n            }\n            maxCount = std::max(maxCount, count);\n        }\n    }\n    return maxCount;\n}\n```",
  "17_graph_highest_degree": "\n\n```cpp\nint highestDegree = 0;\n#pragma omp parallel for\nfor (int i = 0; i < N; ++i) {\n    int base = i * N;\n    int degree = 0;\n    for (int j = 0; j < N; ++j) {\n        degree += A[base + j];\n    }\n    #pragma omp critical\n    if (degree > highestDegree) {\n        highestDegree = degree;\n    }\n}\n```",
  "34_scan_largest_contiguous_subarray_sum": "\n\n```cpp\n#include <vector>\n#include <limits>\n#include <omp.h>\n\nint maximumSubarray(std::vector<int> const& x) {\n    int largestSum = std::numeric_limits<int>::lowest();\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); ++i) {\n        int sum = 0;\n        for (int j = i; j < x.size(); ++j) {\n            sum += x[j];\n            if (sum > largestSum) {\n                largestSum = sum;\n            }\n        }\n    }\n    return largestSum;\n}\n```",
  "24_histogram_count_quartile": "\n\n```cpp\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); ++i) {\n        bins[static_cast<int>(x[i] * 4) & 3]++;\n    }\n}\n```",
  "55_transform_relu": "\n\n```cpp\nvoid relu(std::vector<double> &x) {\n    size_t n = x.size();\n    #pragma omp parallel for\n    for (size_t i = 0; i < n; ++i) {\n        x[i] = (x[i] > 0.0) ? x[i] : 0.0;\n    }\n}\n```",
  "22_histogram_count_quadrants": "\n\n```cpp\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {\n    const int quadrant_index[2][2] = { {0, 3}, {1, 2} };\n    #pragma omp parallel for\n    for (auto const& point : points) {\n        int a = (point.x < 0);\n        int b = (point.y < 0);\n        bins[quadrant_index[a][b]]++;\n    }\n}\n```",
  "57_transform_inverse_offset": "\n\n```cpp\nvoid oneMinusInverse(std::vector<double> &x) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        x[i] = 1.0 - 1.0 / x[i];\n    }\n}\n```",
  "15_graph_edge_count": "\n\n```cpp\nint edgeCount(std::vector<int> const& A, size_t N) {\n    int count = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            count += A[i * N + j];\n        }\n    }\n    return count;\n}\n```",
  "19_graph_shortest_path": "\n\n```cpp\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {\n    std::vector<bool> visited(N, false);\n    std::queue<std::pair<int, int>> q;\n    visited[source] = true;\n    q.push({source, 0});\n    std::vector<std::vector<int>> neighbors(N);\n    for (int current = 0; current < N; ++current) {\n        for (int i = 0; i < N; ++i) {\n            if (A[current * N + i]) {\n                neighbors[current].push_back(i);\n            }\n        }\n    }\n    while (!q.empty()) {\n        auto [current, pathLength] = q.front();\n        q.pop();\n        if (current == dest) {\n            return pathLength;\n        }\n        int nextPath = pathLength + 1;\n        for (int i : neighbors[current]) {\n            if (!visited[i]) {\n                visited[i] = true;\n                q.push({i, nextPath});\n            }\n        }\n    }\n    return std::numeric_limits<int>::max();\n}\n```",
  "58_transform_squaring": "\n\n```cpp\nvoid squareEach(std::vector<int> &x) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        x[i] = x[i] * x[i];\n    }\n}\n```",
  "56_transform_negate_odds": "\n\n```cpp\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        x[i] = (x[i] & 1) ? -x[i] : x[i] >> 1;\n    }\n}\n```",
  "48_sparse_la_sparse_axpy": "\n\n```cpp\nvoid sparseAxpy(double alpha, std::vector<Element> const& x, std::vector<Element> const& y, std::vector<double> &z) {\n    size_t xi = 0, yi = 0;\n    while (xi < x.size() && yi < y.size()) {\n        size_t idx_x = x[xi].index;\n        size_t idx_y = y[yi].index;\n        if (idx_x < idx_y) {\n            z[idx_x] += alpha * x[xi].value;\n            ++xi;\n        } else if (idx_x > idx_y) {\n            z[idx_y] += y[yi].value;\n            ++yi;\n        } else {\n            double prod = alpha * x[xi].value;\n            z[idx_x] += prod + y[yi].value;\n            ++xi;\n            ++yi;\n        }\n    }\n    while (xi < x.size()) {\n        z[x[xi].index] += alpha * x[xi].value;\n        ++xi;\n    }\n    while (yi < y.size()) {\n        z[y[yi].index] += y[yi].value;\n        ++yi;\n    }\n}\n```",
  "28_reduce_smallest_odd_number": "\n\n```cpp\nint smallestOdd(std::vector<int> const& x) {\n    const int max_val = std::numeric_limits<int>::max();\n    return std::reduce(x.begin(), x.end(), max_val, [max_val](int a, int b) {\n        return (a < b) ? (a & 1 ? a : b & 1 ? b : max_val) : (b & 1 ? b : a & 1 ? a : max_val);\n    });\n}\n```",
  "27_reduce_average": "\n\n```cpp\ndouble average(std::vector<double> const& x) {\n    size_t n = x.size();\n    double sum = 0.0;\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        sum += x[i];\n    }\n    return sum / n;\n}\n```",
  "49_sparse_la_sparse_lu_decomp": "\n\n```cpp\n#pragma once\n#include <vector>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n   std::vector<std::vector<double>> fullA(N, std::vector<double>(N, 0));\n   for (const auto& element : A) {\n      fullA[element.row][element.column] = element.value;\n   }\n\n   for (size_t i = 0; i < N; ++i) {\n      for (size_t j = i; j < N; ++j) {\n         U[i * N + j] = fullA[i][j];\n      }\n      for (size_t k = 0; k < i; ++k) {\n         for (size_t j = i; j < N; ++j) {\n            U[i * N + j] -= L[i * N + k] * U[k * N + j];\n         }\n      }\n      for (size_t j = 0; j < i; ++j) {\n         L[i * N + j] = fullA[i][j];\n         for (size_t k = 0; k < j; ++k) {\n            L[i * N + j] -= L[i * N + k] * U[k * N + j];\n         }\n         L[i * N + j] /= U[j * N + j];\n      }\n      L[i * N + i] = 1;\n   }\n}\n```",
  "29_reduce_sum_of_min_of_pairs": "\n\n```cpp\nint64_t sumOfMinimumElements(std::vector<int64_t> const& x, std::vector<int64_t> const& y) {\n    const size_t n = x.size();\n    int64_t total = 0;\n    #pragma omp parallel for reduction(+:total)\n    for (size_t i = 0; i < n; ++i) {\n        total += (x[i] < y[i] ? x[i] : y[i]);\n    }\n    return total;\n}\n```",
  "46_sparse_la_spmm": "\n\n```cpp\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {\n   Y.assign(M * N, 0.0);\n   std::vector<std::vector<std::pair<size_t, double>>> A_cols(K);\n   for (const auto& a : A) {\n      A_cols[a.column].emplace_back(a.row, a.value);\n   }\n   std::vector<std::vector<std::pair<size_t, double>>> X_rows(K);\n   for (const auto& x : X) {\n      X_rows[x.row].emplace_back(x.column, x.value);\n   }\n   for (size_t c = 0; c < K; ++c) {\n      std::sort(X_rows[c].begin(), X_rows[c].end(), [](const auto& p1, const auto& p2) {\n         return p1.first < p2.first;\n      });\n   }\n   #pragma omp parallel for\n   for (size_t c = 0; c < K; ++c) {\n      for (auto& a_pair : A_cols[c]) {\n         size_t a_row = a_pair.first;\n         double a_val = a_pair.second;\n         double* row = &Y[a_row * N];\n         for (auto& x_pair : X_rows[c]) {\n            size_t x_col = x_pair.first;\n            double x_val = x_pair.second;\n            row[x_col] += a_val * x_val;\n         }\n      }\n   }\n}\n```",
  "45_sparse_la_sparse_solve": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <cmath>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid solveLinearSystem(std::vector<COOElement> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n    std::vector<std::vector<double>> matrix(N, std::vector<double>(N, 0.0));\n    std::vector<double> b_copy = b;\n    for (const auto& element : A) {\n        matrix[element.row][element.column] = element.value;\n    }\n    x.assign(N, 0.0);\n    \n    for (size_t i = 0; i < N; ++i) {\n        double maxEl = std::abs(matrix[i][i]);\n        size_t maxRow = i;\n        for (size_t k = i + 1; k < N; ++k) {\n            if (std::abs(matrix[k][i]) > maxEl) {\n                maxEl = std::abs(matrix[k][i]);\n                maxRow = k;\n            }\n        }\n        \n        for (size_t k = i; k < N; ++k) {\n            std::swap(matrix[maxRow][k], matrix[i][k]);\n        }\n        std::swap(b_copy[maxRow], b_copy[i]);\n        \n        double inv_pivot = 1.0 / matrix[i][i];\n        for (size_t k = i + 1; k < N; ++k) {\n            double c = -matrix[k][i] * inv_pivot;\n            for (size_t j = i + 1; j < N; ++j) {\n                matrix[k][j] += c * matrix[i][j];\n            }\n            b_copy[k] += c * b_copy[i];\n        }\n    }\n    \n    for (int i = N - 1; i >= 0; --i) {\n        x[i] = b_copy[i] / matrix[i][i];\n        for (int k = i - 1; k >= 0; --k) {\n            b_copy[k] -= x[i] * matrix[k][i];\n        }\n    }\n}\n```",
  "47_sparse_la_spmv": "\n\n```cpp\n#pragma once\n#include <vector>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < y.size(); ++i) {\n        y[i] *= beta;\n    }\n    std::vector<double> temp(y.size(), 0.0);\n    #pragma omp parallel for\n    for (size_t i = 0; i < A.size(); ++i) {\n        const COOElement& a_ij = A[i];\n        double val = alpha * a_ij.value;\n        temp[a_ij.row] += val * x[a_ij.column];\n    }\n    #pragma omp parallel for\n    for (size_t i = 0; i < y.size(); ++i) {\n        y[i] += temp[i];\n    }\n}\n```",
  "26_reduce_product_of_inverses": "\n\n```cpp\ndouble productWithInverses(std::vector<double> const& x) {\n    double prod_even = 1.0;\n    double prod_odd = 1.0;\n    for (size_t i = 0; i < x.size(); i += 2) {\n        prod_even *= x[i];\n    }\n    for (size_t i = 1; i < x.size(); i += 2) {\n        prod_odd *= x[i];\n    }\n    return prod_even / prod_odd;\n}\n```",
  "25_reduce_xor": "\n\n```cpp\nbool reduceLogicalXOR(std::vector<bool> const& x) {\n    bool res = false;\n    #pragma omp parallel for reduction(xor:res)\n    for (auto it = x.begin(); it != x.end(); ++it) {\n        res ^= *it;\n    }\n    return res;\n}\n```",
  "06_fft_dft": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <complex>\n#include <cmath>\n\n#if !defined(M_PI)\n#define M_PI 3.14159265358979323846\n#endif\n\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>>& output) {\n    int N = x.size();\n    output.resize(N, std::complex<double>(0.0, 0.0));\n    #pragma omp parallel for\n    for (int k = 0; k < N; ++k) {\n        double delta = 2.0 * M_PI * k / N;\n        double t_real = std::cos(delta);\n        double t_imag = -std::sin(delta);\n        std::complex<double> t(t_real, t_imag);\n        std::complex<double> sum(0.0, 0.0);\n        std::complex<double> twiddle(1.0, 0.0);\n        for (int n = 0; n < N; ++n) {\n            sum += x[n] * twiddle;\n            twiddle *= t;\n        }\n        output[k] = sum;\n    }\n}\n```",
  "09_fft_fft_out_of_place": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\n#if !defined(M_PI)\n#define M_PI 3.14159265358979323846\n#endif\n\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {\n    output = x;\n    const unsigned int N = output.size();\n    double thetaT = M_PI / N;\n    std::complex<double> phiT = {std::cos(thetaT), -std::sin(thetaT)};\n    std::complex<double> T = {1.0L, 0.0L};\n    unsigned int k = N;\n    while (k > 1) {\n        unsigned int n = k;\n        k >>= 1;\n        phiT = phiT * phiT;\n        T = {1.0L, 0.0L};\n        for (unsigned int l = 0; l < k; ++l) {\n            for (unsigned int a = l; a < N; a += n) {\n                unsigned int b = a + k;\n                auto t_real = output[a].real - output[b].real;\n                auto t_imag = output[a].imag - output[b].imag;\n                output[a].real += output[b].real;\n                output[a].imag += output[b].imag;\n                output[b].real = t_real * T.real - t_imag * T.imag;\n                output[b].imag = t_real * T.imag + t_imag * T.real;\n            }\n            T = T * phiT;\n        }\n    }\n    unsigned int m = static_cast<unsigned int>(std::log2(N));\n    for (unsigned int a = 0; a < N; ++a) {\n        unsigned int b = a;\n        b = ((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1);\n        b = ((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2);\n        b = ((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4);\n        b = ((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8);\n        b = (b >> 16) | (b << 16);\n        b = b >> (32 - m);\n        if (b > a) {\n            std::swap(output[a], output[b]);\n        }\n    }\n}\n```",
  "14_geometry_closest_pair_1d": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <limits>\n#include <algorithm>\n\ndouble closestPair(std::vector<double> const& x) {\n    if (x.size() < 2) {\n        return 0.0;\n    }\n    std::vector<double> sorted = x;\n    std::sort(sorted.begin(), sorted.end());\n    double minDist = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < sorted.size() - 1; ++i) {\n        double dist = sorted[i + 1] - sorted[i];\n        if (dist < minDist) {\n            minDist = dist;\n        }\n    }\n    return minDist;\n}\n```",
  "03_dense_la_axpy": "\n\n```cpp\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        z[i] = alpha * x[i] + y[i];\n    }\n}\n```",
  "13_geometry_closest_pair_2d": "\n\n```cpp\n#include <vector>\n#include <limits>\n#include <cmath>\n#include <omp.h>\n\nstruct Point {\n    double x, y;\n};\n\ndouble closestPair(std::vector<Point> const& points) {\n    if (points.size() < 2) {\n        return 0.0;\n    }\n    double min_sq = std::numeric_limits<double>::max() * std::numeric_limits<double>::max();\n    for (size_t i = 0; i < points.size() - 1; ++i) {\n        for (size_t j = i + 1; j < points.size(); ++j) {\n            double dx = points[j].x - points[i].x;\n            double dy = points[j].y - points[i].y;\n            double sq_dist = dx * dx + dy * dy;\n            #pragma omp critical\n            if (sq_dist < min_sq) {\n                min_sq = sq_dist;\n            }\n        }\n    }\n    return std::sqrt(min_sq);\n}\n```",
  "07_fft_fft_conjugate": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n\nvoid fftConjugate(std::vector<std::complex<double>>& x) {\n    unsigned int N = x.size();\n    double thetaT = 3.14159265358979323846264338328L / N;\n    std::complex<double> phiT = {std::cos(thetaT), -std::sin(thetaT)};\n    std::complex<double> T = {1.0L, 0.0L};\n    unsigned int k = N;\n    while (k > 1) {\n        unsigned int n = k;\n        k >>= 1;\n        phiT *= phiT;\n        for (unsigned int l = 0; l < k; ++l) {\n            T = {1.0L, 0.0L};\n            for (unsigned int a = l; a < N; a += n) {\n                unsigned int b = a + k;\n                auto t = x[a] - x[b];\n                x[a] += x[b];\n                x[b] = t * T;\n                T *= phiT;\n            }\n        }\n    }\n    unsigned int m = static_cast<unsigned int>(std::log2(N));\n    for (unsigned int a = 0; a < N; ++a) {\n        unsigned int b = a;\n        b = ((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1);\n        b = ((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2);\n        b = ((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4);\n        b = ((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8);\n        b = ((b >> 16) | (b << 16)) >> (32 - m);\n        if (b > a) {\n            std::complex<double> t = x[a];\n            x[a] = x[b];\n            x[b] = t;\n        }\n    }\n    for (size_t i = 0; i < x.size(); ++i) {\n        x[i] = std::conj(x[i]);\n    }\n}\n```",
  "11_geometry_convex_hull_perimeter": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstruct Point {\n    double x, y;\n};\n\ndouble convexHullPerimeter(std::vector<Point> const& points) {\n    if (points.size() < 3) {\n        return 0.0;\n    }\n\n    std::vector<Point> pointsSorted = points;\n    std::sort(pointsSorted.begin(), pointsSorted.end(), [](Point a, Point b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    });\n\n    int n = points.size();\n    std::vector<Point> ans(2 * n);\n    int k = 0;\n\n    // Lower hull\n    for (int i = 0; i < n; ++i) {\n        while (k >= 2) {\n            double x1 = ans[k-1].x - ans[k-2].x;\n            double y1 = ans[k-1].y - ans[k-2].y;\n            double x2 = pointsSorted[i].x - ans[k-2].x;\n            double y2 = pointsSorted[i].y - ans[k-2].y;\n            if (x1 * y2 <= y1 * x2) {\n                k--;\n            } else {\n                break;\n            }\n        }\n        ans[k++] = pointsSorted[i];\n    }\n\n    // Upper hull\n    for (int i = n - 1, t = k + 1; i > 0; --i) {\n        while (k >= t) {\n            double x1 = ans[k-1].x - ans[k-2].x;\n            double y1 = ans[k-1].y - ans[k-2].y;\n            double x2 = pointsSorted[i-1].x - ans[k-2].x;\n            double y2 = pointsSorted[i-1].y - ans[k-2].y;\n            if (x1 * y2 <= y1 * x2) {\n                k--;\n            } else {\n                break;\n            }\n        }\n        ans[k++] = pointsSorted[i-1];\n    }\n\n    ans.resize(k - 1);\n    double perimeter = 0.0;\n\n    for (int i = 0; i < ans.size() - 1; ++i) {\n        double dx = ans[i+1].x - ans[i].x;\n        double dy = ans[i+1].y - ans[i].y;\n        perimeter += std::sqrt(dx*dx + dy*dy);\n    }\n    perimeter += std::sqrt((ans[0].x - ans.back().x)*(ans[0].x - ans.back().x) + (ans[0].y - ans.back().y)*(ans[0].y - ans.back().y));\n    return perimeter;\n}\n```",
  "08_fft_split_fft": "\n\n```cpp\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {\n    std::vector<std::complex<double>> x_copy = x;\n    unsigned int N = x_copy.size();\n    double thetaT = 3.14159265358979323846264338328L / N;\n    std::complex<double> phiT(std::cos(thetaT), -std::sin(thetaT));\n    std::complex<double> T(1.0L);\n\n    unsigned int k = N;\n    while (k > 1) {\n        unsigned int n = k;\n        k >>= 1;\n        phiT *= phiT;\n        T = 1.0L;\n        for (unsigned int l = 0; l < k; ++l) {\n            double T_real = T.real();\n            double T_imag = T.imag();\n            for (unsigned int a = l; a < N; a += n) {\n                unsigned int b = a + k;\n                double x0 = x_copy[a].real();\n                double y0 = x_copy[b].real();\n                double x1 = x_copy[a].imag();\n                double y1 = x_copy[b].imag();\n                double t0 = x0 - y0;\n                double t1 = x1 - y1;\n                x_copy[a].real() = x0 + y0;\n                x_copy[a].imag() = x1 + y1;\n                x_copy[b].real() = t0 * T_real - t1 * T_imag;\n                x_copy[b].imag() = t0 * T_imag + t1 * T_real;\n            }\n            double new_T_real = T_real * phiT.real() - T_imag * phiT.imag();\n            double new_T_imag = T_real * phiT.imag() + T_imag * phiT.real();\n            T.real() = new_T_real;\n            T.imag() = new_T_imag;\n        }\n    }\n\n    unsigned int m = static_cast<unsigned int>(std::log2(N));\n    for (unsigned int a = 0; a < N; ++a) {\n        unsigned int b = a;\n        b = (b & 0xaaaaaaaa) >> 1 | (b & 0x55555555) << 1;\n        b = (b & 0xcccccccc) >> 2 | (b & 0x33333333) << 2;\n        b = (b & 0xf0f0f0f0) >> 4 | (b & 0x0f0f0f0f) << 4;\n        b = (b & 0xff00ff00) >> 8 | (b & 0x00ff00ff) << 8;\n        b = (b >> 16) | (b << 16);\n        b >>= (32 - m);\n        if (b > a) {\n            auto t = x_copy[a];\n            x_copy[a] = x_copy[b];\n            x_copy[b] = t;\n        }\n    }\n\n    for (unsigned int j = 0; j < N; ++j) {\n        r[j] = x_copy[j].real();\n        i[j] = x_copy[j].imag();\n    }\n}\n```",
  "05_fft_inverse_fft": "\n\n```cpp\n#pragma once\n#include <cmath>\n#include <vector>\n#include <complex>\n\n#if !defined(M_PI)\n#define M_PI 3.14159265358979323846\n#endif\n\nvoid fft_helper(std::vector<std::complex<double>> &x) {\n    unsigned int N = x.size();\n    unsigned int k = N;\n    double thetaT = M_PI / N;\n    std::complex<double> phiT = {std::cos(thetaT), -std::sin(thetaT)};\n    while (k > 1) {\n        unsigned int n = k;\n        k >>= 1;\n        phiT = phiT * phiT;\n        std::complex<double> T = 1.0L;\n        for (unsigned int l = 0; l < k; ++l) {\n            auto t0 = x[l] - x[l + k];\n            x[l] += x[l + k];\n            x[l + k] = t0 * T;\n            if (l + n < N) {\n                auto t1 = x[l + n] - x[l + n + k];\n                x[l + n] += x[l + n + k];\n                x[l + n + k] = t1 * T;\n            }\n            T *= phiT;\n        }\n    }\n    unsigned int m = static_cast<unsigned int>(std::log2(N));\n    for (unsigned int a = 0; a < N; ++a) {\n        unsigned int b = a;\n        b = (b & 0xaaaaaaaa) >> 1 | (b & 0x55555555) << 1;\n        b = (b & 0xcccccccc) >> 2 | (b & 0x33333333) << 2;\n        b = (b & 0xf0f0f0f0) >> 4 | (b & 0x0f0f0f0f) << 4;\n        b = (b & 0xff00ff00) >> 8 | (b & 0x00ff00ff) << 8;\n        b = (b >> 16) | (b << 16) >> (32 - m);\n        if (b > a) {\n            auto t = x[a];\n            x[a] = x[b];\n            x[b] = t;\n        }\n    }\n}\n\nvoid ifft(std::vector<std::complex<double>> &x) {\n    std::transform(x.begin(), x.end(), x.begin(), [](auto const& val) { return std::conj(val); });\n    fft_helper(x);\n    std::transform(x.begin(), x.end(), x.begin(), [](auto const& val) { return std::conj(val); });\n    std::transform(x.begin(), x.end(), x.begin(), [&](std::complex<double> c) { return c / static_cast<double>(x.size()); });\n}\n```",
  "10_geometry_convex_hull": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <algorithm>\n\nstruct Point {\n    double x, y;\n};\n\nvoid convexHull(std::vector<Point> const& points, std::vector<Point> &hull) {\n    if (points.size() < 3) {\n        hull = points;\n        return;\n    }\n\n    std::vector<Point> pointsSorted = points;\n    std::sort(pointsSorted.begin(), pointsSorted.end(), [](const Point& a, const Point& b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    });\n\n    int n = points.size();\n    std::vector<Point> ans(2 * n);\n    int k = 0;\n\n    for (int i = 0; i < n; ++i) {\n        while (k >= 2) {\n            double dx1 = ans[k-1].x - ans[k-2].x;\n            double dy1 = ans[k-1].y - ans[k-2].y;\n            double dx2 = pointsSorted[i].x - ans[k-2].x;\n            double dy2 = pointsSorted[i].y - ans[k-2].y;\n            if (dx1 * dy2 <= dy1 * dx2) {\n                k--;\n            } else {\n                break;\n            }\n        }\n        ans[k++] = pointsSorted[i];\n    }\n\n    for (int i = n - 1, t = k + 1; i > 0; --i) {\n        while (k >= t) {\n            double dx1 = ans[k-1].x - ans[k-2].x;\n            double dy1 = ans[k-1].y - ans[k-2].y;\n            double dx2 = pointsSorted[i-1].x - ans[k-2].x;\n            double dy2 = pointsSorted[i-1].y - ans[k-2].y;\n            if (dx1 * dy2 <= dy1 * dx2) {\n                k--;\n            } else {\n                break;\n            }\n        }\n        ans[k++] = pointsSorted[i-1];\n    }\n\n    ans.resize(k - 1);\n    hull = ans;\n}\n```",
  "50_stencil_xor_kernel": "\n\n```cpp\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n    for (size_t i = 0; i < N; ++i) {\n        int *row_i = &input[i * N];\n        int *row_above = (i > 0) ? &input[(i-1) * N] : nullptr;\n        int *row_below = (i < N-1) ? &input[(i+1) * N] : nullptr;\n        for (size_t j = 0; j < N; ++j) {\n            int count = 0;\n            if (row_above) count += row_above[j];\n            if (row_below) count += row_below[j];\n            if (j > 0) count += row_i[j-1];\n            if (j < N-1) count += row_i[j+1];\n            output[i * N + j] = (count == 1) ? 1 : 0;\n        }\n    }\n}\n```",
  "12_geometry_smallest_triangle": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <limits>\n\nstruct Point {\n    double x, y;\n};\n\ndouble triangleArea(Point const& A, Point const& B, Point const& C) {\n    return 0.5 * std::abs(A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y));\n}\n\ndouble smallestArea(std::vector<Point> const& points) {\n    if (points.size() < 3) {\n        return 0;\n    }\n    double minArea = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < points.size() - 2; ++i) {\n        for (size_t j = i + 1; j < points.size() - 1; ++j) {\n            double base = points[i].x * points[j].y - points[j].x * points[i].y;\n            double dx = points[j].x - points[i].x;\n            double dy = points[i].y - points[j].y;\n            double minValForIJ = std::numeric_limits<double>::max();\n            for (size_t k = j + 1; k < points.size(); ++k) {\n                double kx = points[k].x;\n                double ky = points[k].y;\n                double val = base + dx * ky + dy * kx;\n                if (val < 0) {\n                    val = -val;\n                }\n                if (val < minValForIJ) {\n                    minValForIJ = val;\n                }\n            }\n            if (minValForIJ < 2 * minArea) {\n                minArea = minValForIJ * 0.5;\n            }\n        }\n    }\n    return minArea;\n}\n```",
  "52_stencil_1d_jacobi_3-point_stencil": "\n\n```cpp\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {\n    const size_t n = input.size();\n    const double inv3 = 1.0 / 3.0;\n    if (n == 1) {\n        output[0] = input[0] * inv3;\n    } else {\n        output[0] = (input[0] + input[1]) * inv3;\n        output[n-1] = (input[n-1] + input[n-2]) * inv3;\n        for (size_t i = 1; i < n-1; ++i) {\n            output[i] = (input[i-1] + input[i] + input[i+1]) * inv3;\n        }\n    }\n}\n```",
  "02_dense_la_gemm": "\n\n```cpp\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t k = 0; k < K; ++k) {\n            double a = A[i*K + k];\n            for (size_t j = 0; j < N; ++j) {\n                C[i*N + j] += a * B[k*N + j];\n            }\n        }\n    }\n}\n```",
  "51_stencil_edge_kernel": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <algorithm>\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {\n    for (size_t i = 0; i < N; ++i) {\n        #pragma omp parallel for\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 8 * imageIn[i * N + j];\n            if (i > 0) sum -= imageIn[(i - 1) * N + j];\n            if (i < N - 1) sum -= imageIn[(i + 1) * N + j];\n            if (j > 0) sum -= imageIn[i * N + j - 1];\n            if (j < N - 1) sum -= imageIn[i * N + j + 1];\n            if (i > 0 && j > 0) sum -= imageIn[(i - 1) * N + j - 1];\n            if (i > 0 && j < N - 1) sum -= imageIn[(i - 1) * N + j + 1];\n            if (i < N - 1 && j > 0) sum -= imageIn[(i + 1) * N + j - 1];\n            if (i < N - 1 && j < N - 1) sum -= imageIn[(i + 1) * N + j + 1];\n            imageOut[i * N + j] = (sum < 0) ? 0 : (sum > 255) ? 255 : sum;\n        }\n    }\n}\n```",
  "53_stencil_2d_jacobi_5-point_stencil": "\n\n```cpp\n#pragma once\n#include <vector>\n\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {\n    const double inv5 = 1.0 / 5.0;\n    for (size_t i = 0; i < N; ++i) {\n        double *row = input.data() + i * N;\n        double *prev_row = (i > 0) ? input.data() + (i-1) * N : nullptr;\n        double *next_row = (i < N-1) ? input.data() + (i+1) * N : nullptr;\n\n        // j = 0\n        double sum0 = row[0];\n        if (prev_row) sum0 += prev_row[0];\n        if (next_row) sum0 += next_row[0];\n        if (N > 1) sum0 += row[1];\n        output[i * N] = sum0 * inv5;\n\n        // j = N-1\n        if (N > 1) {\n            double sumN1 = row[N-1];\n            if (prev_row) sumN1 += prev_row[N-1];\n            if (next_row) sumN1 += next_row[N-1];\n            sumN1 += row[N-2];\n            output[i * N + N-1] = sumN1 * inv5;\n        } else {\n            output[i * N] = row[0] * inv5; // for N=1, j=0 and j=N-1 are the same\n        }\n\n        // Middle j's (1 <= j < N-1)\n        for (size_t j = 1; j < N-1; ++j) {\n            double sum = row[j] + row[j-1] + row[j+1];\n            if (prev_row) sum += prev_row[j];\n            if (next_row) sum += next_row[j];\n            output[i * N + j] = sum * inv5;\n        }\n    }\n}\n```",
  "40_sort_sort_an_array_of_complex_numbers_by_magnitude": "\n\n```cpp\n#pragma once\n#include <complex>\n#include <vector>\n\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {\n    std::sort(x.begin(), x.end(), [](const std::complex<double> &a, const std::complex<double> &b) {\n        return a.norm() < b.norm();\n    });\n}\n```",
  "54_stencil_game_of_life": "\n\n```cpp\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n    static const int lookup[2][9] = { {0, 0, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 1, 1, 0, 0, 0, 0, 0} };\n    for (size_t i = 0; i < N; ++i) {\n        size_t row = i * N;\n        for (size_t j = 0; j < N; ++j) {\n            size_t idx = row + j;\n            int sum = 0;\n            if (i > 0) {\n                sum += input[idx - N];\n                if (j > 0) sum += input[idx - N - 1];\n                if (j < N - 1) sum += input[idx - N + 1];\n            }\n            if (i < N - 1) {\n                sum += input[idx + N];\n                if (j > 0) sum += input[idx + N - 1];\n                if (j < N - 1) sum += input[idx + N + 1];\n            }\n            if (j > 0) sum += input[idx - 1];\n            if (j < N - 1) sum += input[idx + 1];\n            output[idx] = lookup[input[idx]][sum];\n        }\n    }\n}\n```",
  "04_dense_la_gemv": "\n\n```cpp\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {\n    for (size_t i = 0; i < M; ++i) {\n        double sum = 0.0;\n        for (size_t j = 0; j < N; j += 4) {\n            sum += A[i * N + j] * x[j];\n            if (j + 1 < N) sum += A[i * N + j + 1] * x[j + 1];\n            if (j + 2 < N) sum += A[i * N + j + 2] * x[j + 2];\n            if (j + 3 < N) sum += A[i * N + j + 3] * x[j + 3];\n        }\n        y[i] = sum;\n    }\n}\n```",
  "41_sort_k-th_smallest_element": "\n\n```cpp\nint findKthSmallest(std::vector<int> const& x, int k) {\n    std::vector<int> x_copy(x.begin(), x.end());\n    std::sort(x_copy.begin(), x_copy.end());\n    return x_copy[k-1];\n}\n```",
  "01_dense_la_solve": "\n\n```cpp\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n   std::vector<double> A_copy = A;\n   std::vector<double> b_copy = b;\n   for (size_t i = 0; i < N - 1; ++i) {\n      double pivot = A_copy[i * N + i];\n      if (pivot == 0.0) {\n         return;\n      }\n      double* row_i = A_copy.data() + i * N;\n      #pragma omp parallel for\n      for (size_t j = i + 1; j < N; ++j) {\n         double factor = A_copy[j * N + i] / pivot;\n         double* row_j = A_copy.data() + j * N;\n         for (size_t k = i; k < N; ++k) {\n            row_j[k] -= factor * row_i[k];\n         }\n         b_copy[j] -= factor * b_copy[i];\n      }\n   }\n   for (int i = N - 1; i >= 0; --i) {\n      double sum = 0.0;\n      for (size_t j = i + 1; j < N; ++j) {\n         sum += A_copy[i * N + j] * x[j];\n      }\n      x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n   }\n}\n```",
  "00_dense_la_lu_decomp": "\n\n```cpp\nvoid luFactorize(std::vector<double> &A, size_t N) {\n    for (size_t k = 0; k < N; ++k) {\n        for (size_t i = k + 1; i < N; ++i) {\n            double factor = A[i * N + k] / A[k * N + k];\n            A[i * N + k] = factor;\n            for (size_t j = k + 1; j < N; j += 4) {\n                A[i * N + j] -= factor * A[k * N + j];\n                A[i * N + j + 1] -= factor * A[k * N + j + 1];\n                A[i * N + j + 2] -= factor * A[k * N + j + 2];\n                A[i * N + j + 3] -= factor * A[k * N + j + 3];\n            }\n        }\n    }\n}\n```",
  "43_sort_sort_an_array_of_structs_by_key": "\n\n```cpp\nvoid sortByStartTime(std::vector<Result> &results) {\n    std::sort(results.begin(), results.end(), [](const Result& a, const Result& b) {\n        return a.startTime < b.startTime;\n    });\n}\n```",
  "38_search_find_the_first_even_number": "\n\n```cpp\nsize_t findFirstEven(std::vector<int> const& x) {\n    for (size_t i = 0; i < x.size(); ++i) {\n        if ((x[i] & 1) == 0) {\n            return i;\n        }\n    }\n    return x.size();\n}\n```",
  "44_sort_sort_non-zero_elements": "\n\n```cpp\nvoid sortIgnoreZero(std::vector<int> &x) {\n    size_t n = x.size();\n    std::vector<int> nonZeroElements(n);\n    int nonZeroCount = 0;\n    for (size_t i = 0; i < n; ++i) {\n        if (x[i] != 0) {\n            nonZeroElements[nonZeroCount] = x[i];\n            ++nonZeroCount;\n        }\n    }\n    std::sort(nonZeroElements.begin(), nonZeroElements.begin() + nonZeroCount);\n    int nonZeroIndex = 0;\n    for (size_t i = 0; i < n; ++i) {\n        if (x[i] != 0) {\n            x[i] = nonZeroElements[nonZeroIndex];\n            ++nonZeroIndex;\n        }\n    }\n}\n```",
  "37_search_find_the_closest_number_to_pi": "\n\n```cpp\n#include <vector>\n#include <cmath>\n\nsize_t findClosestToPi(std::vector<double> const& x) {\n    size_t index = 0;\n    double min = std::abs(x[0] - M_PI);\n    for (size_t i = 1; i < x.size(); ++i) {\n        register double diff = std::abs(x[i] - M_PI);\n        if (diff < min) {\n            min = diff;\n            index = i;\n        }\n    }\n    return index;\n}\n```",
  "42_sort_sorted_ranks": "\n\n```cpp\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks_) {\n    std::vector<size_t> indices(x.size());\n    std::iota(indices.begin(), indices.end(), 0);\n    std::sort(indices.begin(), indices.end(), [](size_t i1, size_t i2) { return x[i1] < x[i2]; });\n    for (size_t i = 0; i < indices.size(); ++i) {\n        ranks_[indices[i]] = i;\n    }\n}\n```",
  "36_search_check_if_array_contains_value": "\n\n```cpp\nbool contains(std::vector<int> const& x, int target) {\n    for (int i = 0; i < x.size(); ++i) {\n        if (x[i] == target) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
  "35_search_search_for_last_struct_by_key": "\n\n```cpp\nsize_t findLastShortBook(std::vector<Book> const& books) {\n    size_t idx = books.size() - 1;\n    do {\n        if (books[idx].pages < 100) {\n            return idx;\n        }\n    } while (--idx >= 0);\n    return books.size();\n}\n```",
  "39_search_xor_contains": "\n\n```cpp\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {\n    bool foundInX = false;\n    bool foundInY = false;\n    #pragma omp parallel\n    {\n        #pragma omp private(foundInX, foundInY)\n        #pragma omp task\n        {\n            for (size_t i = 0; i < x.size(); ++i) {\n                if (x[i] == val) {\n                    foundInX = true;\n                    break;\n                }\n            }\n        }\n        #pragma omp task\n        {\n            for (size_t i = 0; i < y.size(); ++i) {\n                if (y[i] == val) {\n                    foundInY = true;\n                    break;\n                }\n            }\n        }\n        #pragma omp barrier\n    }\n    return foundInX ^ foundInY;\n}\n```"
}