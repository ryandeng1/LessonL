{
  "33_scan_reverse_prefix_sum": "\n\n```cpp\nvoid reversePrefixSum(std::vector<int> const& x, std::vector<int> &output) {\n    std::vector<int> reverseX(x.rbegin(), x.rend());\n    std::inclusive_scan(reverseX.begin(), reverseX.end(), output.begin());\n}\n```",
  "23_histogram_first_letter_counts": "\n\n```cpp\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {\n    #pragma omp parallel for\n    for (int i = 0; i < s.size(); ++i) {\n        const char c = s[i][0];\n        const int index = c - 'a';\n        ++bins[index];\n    }\n}\n```",
  "30_scan_prefix_sum": "\n\n```cpp\nvoid prefixSum(std::vector<int64_t> const& x, std::vector<int64_t> &output) {\n    const size_t n = x.size();\n    output[0] = x[0];\n    for (size_t i = 1; i < n; ++i) {\n        output[i] = output[i-1] + x[i];\n    }\n}\n```",
  "24_histogram_count_quartile": "\n\n```cpp\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); ++i) {\n        const double val = x[i];\n        const double frac = val - static_cast<int>(val);\n        const int idx = static_cast<int>(frac * 4.0);\n        ++bins[idx];\n    }\n}\n```",
  "59_transform_map_function": "\n\n```cpp\n#pragma once\n\nbool isPowerOfTwo(int x) {\n    return (x > 0) && !(x & (x - 1));\n}\n\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); ++i) {\n        mask[i] = (x[i] > 0) && !(x[i] & (x[i] - 1));\n    }\n}\n```",
  "32_scan_sum_of_prefix_sum_array": "\n\n```cpp\nint64_t sumOfPrefixSum(std::vector<int64_t> const& x) {\n    int n = x.size();\n    int64_t total = 0;\n    for (int i = 0; i < n; ++i) {\n        total += static_cast<int64_t>(n - i) * x[i];\n    }\n    return total;\n}\n```",
  "19_graph_shortest_path": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {\n    std::vector<std::vector<int>> neighbors(N);\n    for (int u = 0; u < N; ++u) {\n        for (int v = 0; v < N; ++v) {\n            if (A[u * N + v]) {\n                neighbors[u].push_back(v);\n            }\n        }\n    }\n\n    std::vector<bool> visited(N, false);\n    visited[source] = true;\n    std::queue<std::pair<int, int>> queue;\n    queue.push({source, 0});\n\n    while (!queue.empty()) {\n        auto [current, pathLength] = queue.front();\n        queue.pop();\n        if (current == dest) {\n            return pathLength;\n        }\n        for (int i : neighbors[current]) {\n            if (!visited[i]) {\n                visited[i] = true;\n                queue.push({i, pathLength + 1});\n            }\n        }\n    }\n    return std::numeric_limits<int>::max();\n}\n```",
  "20_histogram_pixel_histogram": "\n\n```cpp\n#include <atomic>\nvoid pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {\n    #pragma omp parallel for\n    for (int i = 0; i < image.size(); ++i) {\n        __atomic_add_fetch(&bins[image[i]], 1, __ATOMIC_RELAXED);\n    }\n}\n```",
  "16_graph_largest_component": "\n\n```cpp\nint largestComponent(std::vector<int> const& A, size_t N) {\n    std::vector<std::vector<int>> adj(N);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (A[i * N + j] == 1) {\n                adj[i].push_back(j);\n            }\n        }\n    }\n    std::vector<bool> visited(N, false);\n    int maxCount = 0;\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            int count = 0;\n            std::stack<int> st;\n            visited[i] = true;\n            ++count;\n            st.push(i);\n            while (!st.empty()) {\n                int current = st.top();\n                st.pop();\n                for (int n : adj[current]) {\n                    if (!visited[n]) {\n                        visited[n] = true;\n                        ++count;\n                        st.push(n);\n                    }\n                }\n            }\n            if (count > maxCount) {\n                maxCount = count;\n            }\n        }\n    }\n    return maxCount;\n}\n```",
  "21_histogram_bin_0-100": "\n\n```cpp\nvoid binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {\n    for (size_t i = 0; i < x.size(); ++i) {\n        int val = static_cast<int>(x[i]);\n        bins[val / 10]++;\n    }\n}\n```",
  "31_scan_scan_with_min_function": "\n\n```cpp\nvoid partialMinimums(std::vector<float> &x) {\n    std::inclusive_scan(x.begin(), x.end(), x.begin(), \n        [](const float &x, const float &y) { return __builtin_fminf(x, y); },\n        std::numeric_limits<float>::max());\n}\n```",
  "55_transform_relu": "\n\n```cpp\nvoid relu(std::vector<double> &x) {\n    std::transform(x.begin(), x.end(), x.begin(), [](double v) {\n        return v > 0.0 ? v : 0.0;\n    });\n}\n```",
  "18_graph_count_components": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <limits>\n\nvoid dfs_helper(std::vector<int> const& A, int node, size_t N, std::vector<bool> &visited) {\n    visited[node] = true;\n    const int base = node * static_cast<int>(N);\n    for (int i = 0; i < N; ++i) {\n        if (A[base + i] && !visited[i]) {\n            dfs_helper(A, i, N, visited);\n        }\n    }\n}\n\nint componentCount(std::vector<int> const& A, size_t N) {\n    std::vector<bool> visited(N, false);\n    int count = 0;\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            dfs_helper(A, i, N, visited);\n            ++count;\n        }\n    }\n    return count;\n}\n```",
  "22_histogram_count_quadrants": "\n\n```cpp\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {\n    #pragma omp parallel for\n    for (auto const& p : points) {\n        if (p.y >= 0) {\n            if (p.x >= 0) ++bins[0];\n            else ++bins[1];\n        } else {\n            if (p.x >= 0) ++bins[3];\n            else ++bins[2];\n        }\n    }\n}\n```",
  "15_graph_edge_count": "\n\n```cpp\nint edgeCount(std::vector<int> const& A, size_t N) {\n   int count = 0;\n   #pragma omp parallel for\n   for (int i = 0; i < N; ++i) {\n      int sum = 0;\n      for (int j = 0; j < N; ++j) {\n         sum += A[i * N + j];\n      }\n      count += sum;\n   }\n   return count;\n}\n```",
  "34_scan_largest_contiguous_subarray_sum": "\n\n```cpp\nint maximumSubarray(std::vector<int> const& x) {\n    int largestSum = std::numeric_limits<int>::lowest();\n    const int* x_ptr = x.data();\n    int n = x.size();\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        int currSum = 0;\n        for (int j = i; j < n; ++j) {\n            currSum += x_ptr[j];\n            if (currSum > largestSum) {\n                largestSum = currSum;\n            }\n        }\n    }\n    return largestSum;\n}\n```",
  "57_transform_inverse_offset": "\n\n```cpp\nvoid oneMinusInverse(std::vector<double> &x) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        x[i] = 1.0 - 1.0 / x[i];\n    }\n}\n```",
  "56_transform_negate_odds": "\n\n```cpp\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        x[i] = (x[i] & 1) ? -x[i] : (x[i] >> 1);\n    }\n}\n```",
  "58_transform_squaring": "\n\n```cpp\nvoid squareEach(std::vector<int> &x) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        x[i] = x[i] * x[i];\n    }\n}\n```",
  "17_graph_highest_degree": "\n\n```cpp\nint highestDegree = 0;\nfor (int i = 0; i < N; ++i) {\n    int degree = 0;\n    int base = i * N;\n    #pragma omp parallel for\n    for (int j = 0; j < N; ++j) {\n        degree += A[base + j];\n    }\n    highestDegree = std::max(highestDegree, degree);\n}\n```",
  "48_sparse_la_sparse_axpy": "\n\n```cpp\nvoid sparseAxpy(double alpha, std::vector<Element> const& x, std::vector<Element> const& y, std::vector<double> &z) {\n    size_t xi = 0, yi = 0;\n    while (xi < x.size() && yi < y.size()) {\n        size_t idx_x = x[xi].index;\n        size_t idx_y = y[yi].index;\n        if (idx_x < idx_y) {\n            z[idx_x] += alpha * x[xi].value;\n            ++xi;\n        } else if (idx_x > idx_y) {\n            z[idx_y] += y[yi].value;\n            ++yi;\n        } else {\n            z[idx_x] += alpha * x[xi].value + y[yi].value;\n            ++xi;\n            ++yi;\n        }\n    }\n    while (xi < x.size()) {\n        z[x[xi].index] += alpha * x[xi].value;\n        ++xi;\n    }\n    while (yi < y.size()) {\n        z[y[yi].index] += y[yi].value;\n        ++yi;\n    }\n}\n```",
  "25_reduce_xor": "\n\n```cpp\nbool reduceLogicalXOR(std::vector<bool> const& x) {\n    bool res = false;\n    for (auto b : x) {\n        res ^= b;\n    }\n    return res;\n}\n```",
  "27_reduce_average": "\n\n```cpp\ndouble average(std::vector<double> const& x) {\n    size_t n = x.size();\n    double sum = 0.0;\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < n; ++i) {\n        sum += x[i];\n    }\n    return sum / static_cast<double>(n);\n}\n```",
  "45_sparse_la_sparse_solve": "\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstruct COOElement {\n    size_t row, column;\n    double value;\n};\n\nvoid solveLinearSystem(std::vector<COOElement> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n    std::vector<std::vector<double>> matrix(N, std::vector<double>(N, 0.0));\n    std::vector<double> b_copy = b;\n    for (const auto& element : A) {\n        matrix[element.row][element.column] = element.value;\n    }\n    x.assign(N, 0.0);\n    for (size_t i = 0; i < N; ++i) {\n        double maxEl = std::abs(matrix[i][i]);\n        size_t maxRow = i;\n        for (size_t k = i + 1; k < N; ++k) {\n            if (std::abs(matrix[k][i]) > maxEl) {\n                maxEl = std::abs(matrix[k][i]);\n                maxRow = k;\n            }\n        }\n        for (size_t k = i; k < N; ++k) {\n            std::swap(matrix[maxRow][k], matrix[i][k]);\n        }\n        std::swap(b_copy[maxRow], b_copy[i]);\n        double inv_pivot = 1.0 / matrix[i][i];\n        for (size_t k = i + 1; k < N; ++k) {\n            double c = -matrix[k][i] * inv_pivot;\n            matrix[k][i] = 0.0;\n            for (size_t j = i + 1; j < N; ++j) {\n                matrix[k][j] += c * matrix[i][j];\n            }\n            b_copy[k] += c * b_copy[i];\n        }\n    }\n    for (size_t i = N - 1; i > 0; --i) {\n        double x_i = b_copy[i] / matrix[i][i];\n        x[i] = x_i;\n        for (size_t k = i - 1; k >= 0; --k) {\n            b_copy[k] -= matrix[k][i] * x_i;\n        }\n    }\n    x[0] = b_copy[0] / matrix[0][0];\n}\n```",
  "29_reduce_sum_of_min_of_pairs": "\n\n```cpp\nint64_t sumOfMinimumElements(std::vector<int64_t> const& x, std::vector<int64_t> const& y) {\n    int64_t sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += __builtin_min(x[i], y[i]);\n    }\n    return sum;\n}\n```",
  "46_sparse_la_spmm": "\n\n```cpp\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {\n    Y.assign(M * N, 0.0);\n    std::vector<std::vector<COOElement>> X_by_row(K);\n    for (const auto& x : X) {\n        X_by_row[x.row].push_back(x);\n    }\n    for (auto& row : X_by_row) {\n        std::sort(row.begin(), row.end(), [](const COOElement& a, const COOElement& b) { return a.column < b.column; });\n    }\n    #pragma omp parallel for\n    for (const auto& a : A) {\n        size_t base = a.row * N;\n        auto& row = X_by_row[a.column];\n        for (const auto& x : row) {\n            Y[base + x.column] += a.value * x.value;\n        }\n    }\n}\n```",
  "49_sparse_la_sparse_lu_decomp": "\n\n```cpp\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n    std::vector<std::vector<double>> fullA(N, std::vector<double>(N, 0));\n    for (const auto& e : A) {\n        fullA[e.row][e.column] = e.value;\n    }\n\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = i; j < N; ++j) {\n            double s = 0.0;\n            for (size_t k = 0; k < i; ++k) {\n                s += L[i*N + k] * U[k*N + j];\n            }\n            U[i*N + j] = fullA[i][j] - s;\n        }\n        for (size_t j = 0; j < i; ++j) {\n            double s = 0.0;\n            for (size_t k = 0; k < j; ++k) {\n                s += L[i*N + k] * U[k*N + j];\n            }\n            L[i*N + j] = (fullA[i][j] - s) / U[j*N + j];\n        }\n        L[i*N + i] = 1.0;\n    }\n}\n```",
  "47_sparse_la_spmv": "\n\n```cpp\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < y.size(); ++i) {\n        y[i] *= beta;\n    }\n    for (const auto& a_ij : A) {\n        if (a_ij.row < M && a_ij.column < N) {\n            double val = a_ij.value * x[a_ij.column];\n            y[a_ij.row] += alpha * val;\n        }\n    }\n}\n```",
  "28_reduce_smallest_odd_number": "\n\n```cpp\n#include <vector>\n#include <numeric>\n#include <limits>\n#include <omp.h>\n\nint smallestOdd(std::vector<int> const& x) {\n    int min_odd = std::numeric_limits<int>::max();\n    #pragma omp parallel for\n    for (int num : x) {\n        if (num & 1 && num < min_odd) {\n            #pragma omp critical\n            min_odd = num;\n        }\n    }\n    return min_odd;\n}\n```",
  "06_fft_dft": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <complex>\n#include <cmath>\n\n#if !defined(M_PI)\n#define M_PI 3.14159265358979323846\n#endif\n\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>>& output) {\n    int N = x.size();\n    output.resize(N, std::complex<double>(0, 0));\n    for (int k = 0; k < N; ++k) {\n        double step = 2.0 * M_PI * k / N;\n        std::complex<double> w(cos(step), -sin(step));\n        std::complex<double> term(1.0, 0.0);\n        for (int n = 0; n < N; ++n) {\n            output[k] += x[n] * term;\n            term *= w;\n        }\n    }\n}\n```",
  "26_reduce_product_of_inverses": "\n\n```cpp\ndouble productWithInverses(std::vector<double> const& x) {\n    double product_even = 1.0;\n    double product_odd = 1.0;\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (i & 1) {\n            product_odd *= x[i];\n        } else {\n            product_even *= x[i];\n        }\n    }\n    return product_even / product_odd;\n}\n```",
  "14_geometry_closest_pair_1d": "\n\n```cpp\ndouble closestPair(std::vector<double> const& x) {\n    if (x.size() < 2) {\n        return 0.0;\n    }\n    std::vector<double> sorted(x);\n    std::sort(sorted.begin(), sorted.end());\n    double minDist = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < sorted.size() - 1; ++i) {\n        minDist = std::min(minDist, sorted[i+1] - sorted[i]);\n    }\n    return minDist;\n}\n```",
  "12_geometry_smallest_triangle": "\n\n```cpp\ndouble smallestArea(std::vector<Point> const& points) {\n    if (points.size() < 3) return 0;\n    double minArea = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < points.size() - 2; ++i) {\n        const Point& a = points[i];\n        for (size_t j = i + 1; j < points.size() - 1; ++j) {\n            const Point& b = points[j];\n            const double dx1 = b.x - a.x;\n            const double dy1 = b.y - a.y;\n            for (size_t k = j + 1; k < points.size(); ++k) {\n                const Point& c = points[k];\n                const double dx2 = c.x - a.x;\n                const double dy2 = c.y - a.y;\n                double cross = dx1 * dy2 - dx2 * dy1;\n                if (cross < 0) cross = -cross;\n                if (cross < 2 * minArea) {\n                    minArea = cross * 0.5;\n                }\n            }\n        }\n    }\n    return minArea;\n}\n```",
  "13_geometry_closest_pair_2d": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <limits>\n#include <cmath>\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(Point const& p1, Point const& p2) {\n    return std::sqrt(std::pow(p2.x - p1.x, 2) + std::pow(p2.y - p1.y, 2));\n}\n\ndouble closestPair(std::vector<Point> const& points) {\n    if (points.size() < 2) {\n        return 0.0;\n    }\n    double minDist_sq = std::numeric_limits<double>::max();\n    #pragma omp parallel for\n    for (size_t i = 0; i < points.size() - 1; ++i) {\n        for (size_t j = i + 1; j < points.size(); ++j) {\n            double dx = points[j].x - points[i].x;\n            double dy = points[j].y - points[i].y;\n            double sq = dx * dx + dy * dy;\n            if (sq < minDist_sq) {\n                minDist_sq = sq;\n            }\n        }\n    }\n    return std::sqrt(minDist_sq);\n}\n```",
  "08_fft_split_fft": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <cmath>\n#include <complex>\n\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {\n    std::vector<std::complex<double>> x_copy = x;\n    unsigned int N = x_copy.size();\n    double thetaT = 3.14159265358979323846264338328L / N;\n    std::complex<double> phiT = {std::cos(thetaT), -std::sin(thetaT)};\n    std::complex<double> T = {1.0L, 0.0L};\n    while (N > 1) {\n        unsigned int k = N >> 1;\n        std::complex<double> phiT2 = phiT * phiT;\n        phiT = phiT2;\n        T = {1.0L, 0.0L};\n        for (unsigned int l = 0; l < k; ++l) {\n            double T_real = T.real();\n            double T_imag = T.imag();\n            for (unsigned int a = l; a < N; a += k) {\n                unsigned int b = a + k;\n                auto t = x_copy[a] - x_copy[b];\n                x_copy[a] = x_copy[a] + x_copy[b];\n                x_copy[b] = t * {T_real, T_imag};\n            }\n            T = T * phiT;\n        }\n        N = k;\n    }\n    unsigned int m = 0;\n    while ((1u << m) < N) ++m;\n    m--;\n    for (unsigned int a = 0; a < N; ++a) {\n        unsigned int b = a;\n        b = (b & 0x55555555) << 1 | (b & 0xaaaaaaaa) >> 1;\n        b = (b & 0x33333333) << 2 | (b & 0xcccccccc) >> 2;\n        b = (b & 0x0f0f0f0f) << 4 | (b & 0xf0f0f0f0) >> 4;\n        b = (b & 0x00ff00ff) << 8 | (b & 0xff00ff00) >> 8;\n        b = (b >> 16) | (b << 16);\n        b >>= (32 - m);\n        if (b > a) {\n            auto t = x_copy[a];\n            x_copy[a] = x_copy[b];\n            x_copy[b] = t;\n        }\n    }\n    for (unsigned int j = 0; j < N; ++j) {\n        r[j] = x_copy[j].real();\n        i[j] = x_copy[j].imag();\n    }\n}\n```",
  "09_fft_fft_out_of_place": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <cmath>\n#include <complex>\n\n#if !defined(M_PI)\n#define M_PI 3.14159265358979323846\n#endif\n\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {\n    output = x;\n    unsigned int N = output.size();\n    double thetaT = M_PI / N;\n    std::complex<double> phiT(cos(thetaT), -sin(thetaT));\n    std::complex<double> T(1.0L);\n\n    while (N > 1) {\n        unsigned int k = N;\n        N >>= 1;\n        phiT *= phiT;\n        std::complex<double> T0 = T;\n        for (unsigned int l = 0; l < k; ++l) {\n            for (unsigned int a = l; a < output.size(); a += k) {\n                unsigned int b = a + N;\n                auto t = output[a] - output[b];\n                output[a] += output[b];\n                output[b] = t * T;\n            }\n            T = T0 * phiT;\n        }\n    }\n\n    unsigned int m = 0;\n    while (1 << m < N) ++m;\n    for (unsigned int a = 0; a < N; ++a) {\n        unsigned int b = a;\n        b = (b & 0xaaaaaaaa) >> 1 | (b & 0x55555555) << 1;\n        b = (b & 0xcccccccc) >> 2 | (b & 0x33333333) << 2;\n        b = (b & 0xf0f0f0f0) >> 4 | (b & 0x0f0f0f0f) << 4;\n        b = (b & 0xff00ff00) >> 8 | (b & 0x00ff00ff) << 8;\n        b = (b >> 16) | (b << 16);\n        b >>= (32 - m);\n        if (b > a) {\n            std::swap(output[a], output[b]);\n        }\n    }\n}\n```",
  "52_stencil_1d_jacobi_3-point_stencil": "\n\n```cpp\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {\n    size_t n = input.size();\n    output[0] = (input[0] + (n > 1 ? input[1] : 0.0)) / 3.0;\n    if (n > 1) {\n        output[n-1] = (input[n-2] + input[n-1]) / 3.0;\n    }\n    for (size_t i = 1; i < n-1; ++i) {\n        output[i] = (input[i-1] + input[i] + input[i+1]) / 3.0;\n    }\n}\n```",
  "11_geometry_convex_hull_perimeter": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstruct Point {\n    double x, y;\n};\n\ndouble convexHullPerimeter(std::vector<Point> const& points) {\n    if (points.size() < 3) {\n        return 0.0;\n    }\n\n    std::vector<Point> pointsSorted = points;\n    std::sort(pointsSorted.begin(), pointsSorted.end(), [](Point const& a, Point const& b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    });\n\n    int n = points.size();\n    std::vector<Point> ans(2 * n);\n    int k = 0;\n\n    // Lower hull\n    for (int i = 0; i < n; ++i) {\n        while (k >= 2) {\n            const Point& a = ans[k-2];\n            const Point& b = ans[k-1];\n            const Point& c = pointsSorted[i];\n            double dx_ab = b.x - a.x;\n            double dy_ab = b.y - a.y;\n            double dx_ac = c.x - a.x;\n            double dy_ac = c.y - a.y;\n            if (dx_ab * dy_ac <= dy_ab * dx_ac) {\n                k--;\n            } else {\n                break;\n            }\n        }\n        ans[k++] = pointsSorted[i];\n    }\n\n    // Upper hull\n    int t = k + 1;\n    for (int i = n - 1; i > 0; --i) {\n        while (k >= t) {\n            const Point& a = ans[k-2];\n            const Point& b = ans[k-1];\n            const Point& c = pointsSorted[i-1];\n            double dx_ab = b.x - a.x;\n            double dy_ab = b.y - a.y;\n            double dx_ac = c.x - a.x;\n            double dy_ac = c.y - a.y;\n            if (dx_ab * dy_ac <= dy_ab * dx_ac) {\n                k--;\n            } else {\n                break;\n            }\n        }\n        ans[k++] = pointsSorted[i-1];\n    }\n\n    ans.resize(k - 1);\n\n    double perimeter = 0.0;\n    for (int i = 0; i < ans.size() - 1; ++i) {\n        double dx = ans[i+1].x - ans[i].x;\n        double dy = ans[i+1].y - ans[i].y;\n        perimeter += std::sqrt(dx*dx + dy*dy);\n    }\n    double dx = ans[0].x - ans.back().x;\n    double dy = ans[0].y - ans.back().y;\n    perimeter += std::sqrt(dx*dx + dy*dy);\n\n    return perimeter;\n}\n```",
  "05_fft_inverse_fft": "\n\n```cpp\n#pragma once\n#include <cmath>\n#include <vector>\n#include <complex>\n\n#if !defined(M_PI)\n#define M_PI 3.14159265358979323846\n#endif\n\nvoid fft_helper(std::vector<std::complex<double>> &x) {\n    unsigned int N = x.size();\n    unsigned int k = N;\n    double thetaT = M_PI / static_cast<double>(N);\n    std::complex<double> phiT = {std::cos(thetaT), -std::sin(thetaT)};\n    std::complex<double> T = {1.0L};\n    while (k > 1) {\n        unsigned int n = k;\n        k >>= 1;\n        phiT *= phiT;\n        T = {1.0L};\n        for (unsigned int l = 0; l < k; ++l) {\n            for (unsigned int a = l; a < N; a += n) {\n                unsigned int b = a + k;\n                auto t = x[a] - x[b];\n                x[a] += x[b];\n                x[b] = t * T;\n            }\n            T *= phiT;\n        }\n    }\n    unsigned int m = static_cast<unsigned int>(std::log2(N));\n    for (unsigned int a = 0; a < N; ++a) {\n        unsigned int b = a;\n        b = (b & 0xaaaaaaaa) >> 1 | (b & 0x55555555) << 1;\n        b = (b & 0xcccccccc) >> 2 | (b & 0x33333333) << 2;\n        b = (b & 0xf0f0f0f0) >> 4 | (b & 0x0f0f0f0f) << 4;\n        b = (b & 0xff00ff00) >> 8 | (b & 0x00ff00ff) << 8;\n        b = (b >> 16) | (b << 16);\n        b >>= (32 - m);\n        if (b > a) {\n            auto t = x[a];\n            x[a] = x[b];\n            x[b] = t;\n        }\n    }\n}\n```",
  "03_dense_la_axpy": "\n\n```cpp\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        z[i] = alpha * x[i] + y[i];\n    }\n}\n```",
  "10_geometry_convex_hull": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <algorithm>\n\nstruct Point {\n    double x, y;\n};\n\nvoid convexHull(std::vector<Point> const& points, std::vector<Point> &hull) {\n    if (points.size() < 3) {\n        hull = points;\n        return;\n    }\n\n    std::vector<Point> pointsSorted = points;\n    std::sort(pointsSorted.begin(), pointsSorted.end(), [](const Point& a, const Point& b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    });\n\n    const int n = points.size();\n    std::vector<Point> ans(2 * n);\n    int k = 0;\n\n    for (int i = 0; i < n; ++i) {\n        while (k >= 2) {\n            const Point& a = ans[k-2];\n            const Point& b = ans[k-1];\n            const Point& c = pointsSorted[i];\n            double x0 = a.x;\n            double y0 = a.y;\n            double x1 = b.x;\n            double y1 = b.y;\n            double dx1 = x1 - x0;\n            double dy1 = y1 - y0;\n            double x2 = c.x;\n            double y2 = c.y;\n            double dx2 = x2 - x0;\n            double dy2 = y2 - y0;\n            double cross = dx1 * dy2 - dy1 * dx2;\n            if (cross <= 0) {\n                k--;\n            } else {\n                break;\n            }\n        }\n        ans[k++] = pointsSorted[i];\n    }\n\n    for (int i = n - 1, t = k + 1; i > 0; --i) {\n        while (k >= t) {\n            const Point& a = ans[k-2];\n            const Point& b = ans[k-1];\n            const Point& c = pointsSorted[i-1];\n            double x0 = a.x;\n            double y0 = a.y;\n            double x1 = b.x;\n            double y1 = b.y;\n            double dx1 = x1 - x0;\n            double dy1 = y1 - y0;\n            double x2 = c.x;\n            double y2 = c.y;\n            double dx2 = x2 - x0;\n            double dy2 = y2 - y0;\n            double cross = dx1 * dy2 - dy1 * dx2;\n            if (cross <= 0) {\n                k--;\n            } else {\n                break;\n            }\n        }\n        ans[k++] = pointsSorted[i-1];\n    }\n\n    ans.resize(k - 1);\n    hull = ans;\n}\n```",
  "50_stencil_xor_kernel": "\n\n```cpp\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n    for (size_t i = 0; i < N; ++i) {\n        int *curr = &input[i * N];\n        int *prev = (i > 0) ? &input[(i - 1) * N] : nullptr;\n        int *next = (i < N - 1) ? &input[(i + 1) * N] : nullptr;\n        int *out = &output[i * N];\n        int prev_in_row = 0;\n        for (size_t j = 0; j < N; ++j) {\n            int cnt = 0;\n            if (prev) cnt += prev[j];\n            if (next) cnt += next[j];\n            if (j > 0) cnt += prev_in_row;\n            if (j < N - 1) cnt += curr[j + 1];\n            out[j] = (cnt == 1);\n            prev_in_row = curr[j];\n        }\n    }\n}\n```",
  "04_dense_la_gemv": "\n\n```cpp\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {\n    for (size_t i = 0; i < M; ++i) {\n        double *row = &A[i * N];\n        y[i] = 0.0;\n        for (size_t j = 0; j < N; j += 4) {\n            y[i] += row[j] * x[j];\n            y[i] += row[j+1] * x[j+1];\n            y[i] += row[j+2] * x[j+2];\n            y[i] += row[j+3] * x[j+3];\n        }\n    }\n}\n```",
  "02_dense_la_gemm": "\n\n```cpp\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {\n    for (size_t i = 0; i < M; ++i) {\n        for (size_t k = 0; k < K; ++k) {\n            double a_ik = A[i * K + k];\n            for (size_t j = 0; j < N; j += 4) {\n                if (j + 3 < N) {\n                    double b0 = B[k * N + j];\n                    double b1 = B[k * N + j + 1];\n                    double b2 = B[k * N + j + 2];\n                    double b3 = B[k * N + j + 3];\n                    C[i * N + j] += a_ik * b0;\n                    C[i * N + j + 1] += a_ik * b1;\n                    C[i * N + j + 2] += a_ik * b2;\n                    C[i * N + j + 3] += a_ik * b3;\n                } else {\n                    for (size_t jj = j; jj < N; ++jj) {\n                        C[i * N + jj] += a_ik * B[k * N + jj];\n                    }\n                }\n            }\n        }\n    }\n}\n```",
  "51_stencil_edge_kernel": "\n\n```cpp\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            int val = imageIn[i * N + j];\n            int sum = (val << 3);\n            if (i > 0) {\n                sum -= imageIn[(i - 1) * N + j];\n                if (j > 0) sum -= imageIn[(i - 1) * N + (j - 1)];\n                if (j < N - 1) sum -= imageIn[(i - 1) * N + (j + 1)];\n            }\n            if (i < N - 1) {\n                sum -= imageIn[(i + 1) * N + j];\n                if (j > 0) sum -= imageIn[(i + 1) * N + (j - 1)];\n                if (j < N - 1) sum -= imageIn[(i + 1) * N + (j + 1)];\n            }\n            if (j > 0) sum -= imageIn[i * N + (j - 1)];\n            if (j < N - 1) sum -= imageIn[i * N + (j + 1)];\n            imageOut[i * N + j] = (sum < 0) ? 0 : (sum > 255 ? 255 : sum);\n        }\n    }\n}\n```",
  "07_fft_fft_conjugate": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n\nvoid fftConjugate(std::vector<std::complex<double>>& x) {\n    unsigned int N = x.size();\n    if (N <= 1) return;\n\n    double thetaT = 3.14159265358979323846264338328L / N;\n    std::complex<double> phiT(cos(thetaT), -sin(thetaT));\n    std::complex<double> T(1.0L);\n    unsigned int m = static_cast<unsigned int>(log2(N));\n\n    // Precompute bit-reversal indices\n    std::vector<unsigned int> rev(N);\n    for (unsigned int i = 0; i < N; ++i) {\n        rev[i] = (i & 0xaaaaaaaa) >> 1 | (i & 0x55555555) << 1;\n        rev[i] = (rev[i] & 0xcccccccc) >> 2 | (rev[i] & 0x33333333) << 2;\n        rev[i] = (rev[i] & 0xf0f0f0f0) >> 4 | (rev[i] & 0x0f0f0f0f) << 4;\n        rev[i] = (rev[i] & 0xff00ff00) >> 8 | (rev[i] & 0x00ff00ff) << 8;\n        rev[i] = (rev[i] >> 16) | (rev[i] << 16);\n        rev[i] >>= (32 - m);\n    }\n\n    // DFT\n    unsigned int k = N;\n    while (k > 1) {\n        unsigned int n = k;\n        k >>= 1;\n        phiT *= phiT;\n        T = 1.0L;\n        for (unsigned int l = 0; l < k; ++l) {\n            for (unsigned int a = l; a < N; a += n) {\n                unsigned int b = a + k;\n                auto t = x[a] - x[b];\n                x[a] += x[b];\n                x[b] = t * T;\n            }\n            T *= phiT;\n        }\n    }\n\n    // Bit-reversal\n    for (unsigned int a = 0; a < N; ++a) {\n        unsigned int b = rev[a];\n        if (b > a) {\n            auto t = x[a];\n            x[a] = x[b];\n            x[b] = t;\n        }\n    }\n\n    // Conjugate\n    for (size_t i = 0; i < x.size(); ++i) {\n        x[i] = std::conj(x[i]);\n    }\n}\n```",
  "53_stencil_2d_jacobi_5-point_stencil": "\n\n```cpp\n#pragma once\n#include <vector>\n\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {\n    for (size_t i = 0; i < N; ++i) {\n        double* row_i = input.data() + i * N;\n        double* row_i_minus = (i > 0) ? input.data() + (i-1) * N : nullptr;\n        double* row_i_plus = (i < N-1) ? input.data() + (i+1) * N : nullptr;\n\n        // j = 0\n        double sum0 = row_i[0];\n        if (i > 0) sum0 += row_i_minus[0];\n        if (i < N-1) sum0 += row_i_plus[0];\n        if (N > 1) sum0 += row_i[1];\n        output[i * N + 0] = sum0 * 0.2;\n\n        // j from 1 to N-2\n        for (size_t j = 1; j < N-1; ++j) {\n            double sum = row_i[j] + row_i[j-1] + row_i[j+1];\n            if (i > 0) sum += row_i_minus[j];\n            if (i < N-1) sum += row_i_plus[j];\n            output[i * N + j] = sum * 0.2;\n        }\n\n        // j = N-1\n        double sum_last = row_i[N-1];\n        if (i > 0) sum_last += row_i_minus[N-1];\n        if (i < N-1) sum_last += row_i_plus[N-1];\n        if (N > 1) sum_last += row_i[N-2];\n        output[i * N + N-1] = sum_last * 0.2;\n    }\n}\n```",
  "54_stencil_game_of_life": "\n\n```cpp\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n    for (size_t i = 0; i < N; ++i) {\n        size_t base = i * N;\n        for (size_t j = 0; j < N; ++j) {\n            int sum = 0;\n            if (i > 0) {\n                sum += input[base - N + j];\n                if (j > 0) sum += input[base - N + j - 1];\n                if (j < N - 1) sum += input[base - N + j + 1];\n            }\n            if (j > 0) sum += input[base + j - 1];\n            if (j < N - 1) sum += input[base + j + 1];\n            if (i < N - 1) {\n                sum += input[base + N + j];\n                if (j > 0) sum += input[base + N + j - 1];\n                if (j < N - 1) sum += input[base + N + j + 1];\n            }\n            output[base + j] = input[base + j] ? (sum == 2 || sum == 3) : (sum == 3);\n        }\n    }\n}\n```",
  "38_search_find_the_first_even_number": "\n\n```cpp\nsize_t findFirstEven(std::vector<int> const& x) {\n    for (size_t i = 0; i < x.size(); ++i) {\n        if ((x[i] & 1) == 0) {\n            return i;\n        }\n    }\n    return x.size();\n}\n```",
  "43_sort_sort_an_array_of_structs_by_key": "\n\n```cpp\n#pragma once\n#include <vector>\n\nstruct Result {\n   int startTime, duration;\n   float value;\n};\n\nstruct CompareByStartTime {\n   bool operator()(const Result& a, const Result& b) const {\n      return a.startTime < b.startTime;\n   }\n};\n\nvoid sortByStartTime(std::vector<Result> &results) {\n   std::sort(results.begin(), results.end(), CompareByStartTime());\n}\n```",
  "01_dense_la_solve": "\n\n```cpp\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n    std::vector<double> A_copy = A;\n    std::vector<double> b_copy = b;\n    for (size_t i = 0; i < N - 1; ++i) {\n        double pivot = A_copy[i * N + i];\n        if (pivot == 0.0) {\n            return;\n        }\n        double *row_i = &A_copy[i * N];\n        for (size_t j = i + 1; j < N; ++j) {\n            double factor = A_copy[j * N + i] / pivot;\n            double *row_j = &A_copy[j * N];\n            for (size_t k = i; k < N; ++k) {\n                row_j[k] -= factor * row_i[k];\n            }\n            b_copy[j] -= factor * b_copy[i];\n        }\n    }\n    for (int i = N - 1; i >= 0; --i) {\n        double sum = 0.0;\n        for (size_t j = i + 1; j < N; ++j) {\n            sum += A_copy[i * N + j] * x[j];\n        }\n        x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n    }\n}\n```",
  "44_sort_sort_non-zero_elements": "\n\n```cpp\nvoid sortIgnoreZero(std::vector<int> &x) {\n    std::vector<int> nonZeroElements;\n    nonZeroElements.reserve(x.size());\n\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] != 0) {\n            nonZeroElements.push_back(x[i]);\n        }\n    }\n\n    std::sort(nonZeroElements.begin(), nonZeroElements.end());\n\n    size_t idx = 0;\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] != 0) {\n            x[i] = nonZeroElements[idx++];\n        }\n    }\n}\n```",
  "37_search_find_the_closest_number_to_pi": "\n\n```cpp\n#include <cmath>\n#include <vector>\n\nsize_t findClosestToPi(std::vector<double> const& x) {\n    size_t index = 0;\n    double min = std::abs(x[0] - M_PI);\n    #pragma omp parallel for\n    for (size_t i = 1; i < x.size(); ++i) {\n        double diff = std::abs(x[i] - M_PI);\n        if (diff < min) {\n            #pragma omp critical\n            {\n                min = diff;\n                index = i;\n            }\n        }\n    }\n    return index;\n}\n```",
  "41_sort_k-th_smallest_element": "\n\n```cpp\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nint findKthSmallest(std::vector<int> const& x, int k) {\n    std::vector<int> x_copy(x.size());\n    memcpy(x_copy.data(), x.data(), sizeof(int) * x.size());\n    std::sort(x_copy.begin(), x_copy.end());\n    return x_copy[k-1];\n}\n```",
  "40_sort_sort_an_array_of_complex_numbers_by_magnitude": "\n\n```cpp\n#include <complex>\n#include <vector>\n#include <algorithm>\n\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {\n    size_t n = x.size();\n    if (n == 0) return;\n    std::vector<std::complex<double>> temp = x;\n    std::vector<double> sq_mags(n);\n    for (size_t i = 0; i < n; ++i) {\n        sq_mags[i] = temp[i].real() * temp[i].real() + temp[i].imag() * temp[i].imag();\n    }\n    std::vector<int> indices(n);\n    for (size_t i = 0; i < n; ++i) {\n        indices[i] = i;\n    }\n    std::sort(indices.begin(), indices.end(), [&](int i, int j) {\n        return sq_mags[i] < sq_mags[j];\n    });\n    for (size_t i = 0; i < n; ++i) {\n        x[i] = temp[indices[i]];\n    }\n}\n```",
  "36_search_check_if_array_contains_value": "\n\n```cpp\nbool contains(std::vector<int> const& x, int target) {\n    for (size_t i = 0; i < x.size(); i += 2) {\n        if (x[i] == target) return true;\n        if (i + 1 < x.size() && x[i + 1] == target) return true;\n    }\n    return false;\n}\n```",
  "42_sort_sorted_ranks": "\n\n```cpp\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks_) {\n    const size_t n = x.size();\n    std::vector<size_t> indices(n);\n    std::iota(indices.begin(), indices.end(), 0);\n    std::sort(indices.begin(), indices.end(), [&x](size_t i1, size_t i2) {\n        return x[i1] < x[i2];\n    });\n    for (size_t i = 0; i < n; ++i) {\n        ranks_[indices[i]] = i;\n    }\n}\n```",
  "35_search_search_for_last_struct_by_key": "\n\n```cpp\nsize_t findLastShortBook(std::vector<Book> const& books) {\n    size_t n = books.size();\n    for (size_t i = n - 1; i >= 0; --i) {\n        if (books[i].pages < 100) {\n            return i;\n        }\n    }\n    return n;\n}\n```",
  "39_search_xor_contains": "\n\n```cpp\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {\n    bool foundInX = false;\n    bool foundInY = false;\n\n    #pragma omp parallel\n    {\n        bool foundInX_local = false;\n        bool foundInY_local = false;\n\n        for (size_t i = 0; i < x.size(); ++i) {\n            if (x[i] == val) {\n                foundInX_local = true;\n                break;\n            }\n        }\n\n        for (size_t i = 0; i < y.size(); ++i) {\n            if (y[i] == val) {\n                foundInY_local = true;\n                break;\n            }\n        }\n\n        #pragma omp critical\n        {\n            foundInX = foundInX_local;\n            foundInY = foundInY_local;\n        }\n    }\n\n    return foundInX ^ foundInY;\n}\n```",
  "00_dense_la_lu_decomp": "\n\n```cpp\nvoid luFactorize(std::vector<double> &A, size_t N) {\n    for (size_t k = 0; k < N; ++k) {\n        double denom = A[k * N + k];\n        for (size_t i = k + 1; i < N; ++i) {\n            double factor = A[i * N + k] / denom;\n            for (size_t j = k + 1; j < N; ++j) {\n                A[i * N + j] -= factor * A[k * N + j];\n            }\n        }\n    }\n}\n```"
}