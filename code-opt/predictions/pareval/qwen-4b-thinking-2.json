{
  "59_transform_map_function": "\n\n```cpp\n#pragma once\n\nbool isPowerOfTwo(int x) {\n    return (x > 0) && !(x & (x - 1));\n}\n\n/* Apply the isPowerOfTwo function to every value in x and store the results in mask.\n   Example:\n   \n   input: [8, 0, 9, 7, 15, 64, 3]\n   output: [true, false, false, false, false, true, false]\n*/\nvoid mapPowersOfTwo(std::vector<int> const& x, std::vector<bool> &mask) {\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        mask[i] = isPowerOfTwo(x[i]);\n    }\n}\n```",
  "15_graph_edge_count": "\n\n```cpp\nint edgeCount(std::vector<int> const& A, size_t N) {\n    int count = 0;\n    #pragma omp parallel for reduction(+:count)\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (A[i * N + j] == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```",
  "30_scan_prefix_sum": "\n\n```cpp\n#pragma once\n#include <numeric>\n#include <vector>\n#include <execution>\n\nvoid prefixSum(std::vector<int64_t> const& x, std::vector<int64_t> &output) {\n    std::inclusive_scan(std::execution::par, x.begin(), x.end(), output.begin());\n}\n```",
  "17_graph_highest_degree": "\n\n```cpp\n#pragma once\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <limits>\n\nint maxDegree(std::vector<int> const& A, size_t N) {\n   int highestDegree = 0;\n   #pragma omp parallel for reduction(max: highestDegree)\n   for (int i = 0; i < N; i++) {\n      int degree = 0;\n      for (int j = 0; j < N; j++) {\n         degree += A[i * N + j];\n      }\n   }\n   return highestDegree;\n}\n```",
  "20_histogram_pixel_histogram": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <array>\n#include <omp.h>\n\nvoid pixelCounts(std::vector<int> const& image, std::array<size_t, 256> &bins) {\n    #pragma omp parallel for\n    for (int i = 0; i < image.size(); i++) {\n        __sync_fetch_and_add(&bins[image[i]], 1);\n    }\n}\n```",
  "31_scan_scan_with_min_function": "\n\n```cpp\nvoid partialMinimums(std::vector<float> &x) {\n    for (size_t i = 1; i < x.size(); ++i) {\n        x[i] = std::min(x[i], x[i-1]);\n    }\n}\n```",
  "32_scan_sum_of_prefix_sum_array": "\n\n```cpp\n#pragma once\n#include <omp.h>\n#include <vector>\n\n/* Compute the prefix sum array of the vector x and return its sum.\n   Example:\n   input: [-7, 2, 1, 9, 4, 8]\n   output: 15\n*/\nint64_t sumOfPrefixSum(std::vector<int64_t> const& x) {\n    size_t n = x.size();\n    int64_t total = 0;\n    #pragma omp parallel for reduction(+:total)\n    for (size_t i = 0; i < n; i++) {\n        total += x[i] * (n - i);\n    }\n    return total;\n}\n```",
  "57_transform_inverse_offset": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <omp.h>\n\nvoid oneMinusInverse(std::vector<double> &x) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        x[i] = 1.0 - 1.0 / x[i];\n    }\n}\n```",
  "33_scan_reverse_prefix_sum": "\n\n```cpp\nvoid reversePrefixSum(std::vector<int> const& x, std::vector<int> &output) {\n    int n = x.size();\n    if (n == 0) return;\n    output[0] = x[n - 1];\n    for (int i = 1; i < n; ++i) {\n        output[i] = output[i - 1] + x[n - 1 - i];\n    }\n}\n```",
  "56_transform_negate_odds": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <omp.h>\n\nvoid negateOddsAndHalveEvens(std::vector<int> &x) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); ++i) {\n        if (x[i] & 1) {\n            x[i] = -x[i];\n        } else {\n            x[i] = x[i] >> 1;\n        }\n    }\n}\n```",
  "21_histogram_bin_0-100": "\n\n```cpp\n#pragma once\n#include <array>\n#include <vector>\n#include <omp.h>\n\nvoid binsBy10Count(std::vector<double> const& x, std::array<size_t, 10> &bins) {\n    #pragma omp parallel for schedule(static)\n    for (size_t i = 0; i < x.size(); i++) {\n        const size_t bin = static_cast<size_t>(x[i] / 10.0);\n        #pragma omp atomic\n        bins[bin]++;\n    }\n}\n```",
  "19_graph_shortest_path": "\n\n```cpp\nint shortestPathLength(std::vector<int> const& A, size_t N, int source, int dest) {\n   std::vector<bool> visited(N, false);\n   std::vector<int> levels(N, -1);\n   std::queue<int> queue;\n   visited[source] = true;\n   levels[source] = 0;\n   queue.push(source);\n\n   while (!queue.empty()) {\n      int current = queue.front();\n      queue.pop();\n      if (current == dest) {\n         return levels[current];\n      }\n      #pragma omp parallel for\n      for (int i = 0; i < N; ++i) {\n         if (A[current*N + i] && !visited[i]) {\n            visited[i] = true;\n            levels[i] = levels[current] + 1;\n            queue.push(i);\n         }\n      }\n   }\n   return std::numeric_limits<int>::max();\n}\n```",
  "18_graph_count_components": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <stack>\n#include <omp.h>\n\nvoid dfs_iterative(std::vector<int> const& A, int start, size_t N, std::vector<bool> &visited) {\n    std::stack<int> stack;\n    stack.push(start);\n    visited[start] = true;\n    while (!stack.empty()) {\n        int node = stack.top();\n        stack.pop();\n        for (int i = 0; i < N; i++) {\n            if (A[node * N + i] == 1 && !visited[i]) {\n                visited[i] = true;\n                stack.push(i);\n            }\n        }\n    }\n}\n\nint componentCount(std::vector<int> const& A, size_t N) {\n    std::vector<bool> visited(N, false);\n    int count = 0;\n    #pragma omp parallel for schedule(static)\n    for (int i = 0; i < N; i++) {\n        #pragma omp critical\n        if (!visited[i]) {\n            dfs_iterative(A, i, N, visited);\n            #pragma omp critical\n            count++;\n        }\n    }\n    return count;\n}\n```",
  "55_transform_relu": "\n\n```cpp\n#pragma once\n#include <vector>\n\nvoid relu(std::vector<double> &x) {\n    #pragma omp parallel for num_threads(8)\n    for (size_t i = 0; i < x.size(); ++i) {\n        x[i] = (x[i] > 0.0) ? x[i] : 0.0;\n    }\n}\n```",
  "58_transform_squaring": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <omp.h>\n\nvoid squareEach(std::vector<int> &x) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        x[i] = x[i] * x[i];\n    }\n}\n```",
  "23_histogram_first_letter_counts": "\n\n```cpp\n#pragma once\n#include <array>\n#include <string>\n#include <vector>\n\nvoid firstLetterCounts(std::vector<std::string> const& s, std::array<size_t, 26> &bins) {\n    #pragma omp parallel for\n    for (int i = 0; i < s.size(); i++) {\n        const char c = s[i][0];\n        const int index = c - 'a';\n        __atomic_fetch_add(&bins[index], 1, __ATOMIC_SEQ_CST);\n    }\n}\n```",
  "24_histogram_count_quartile": "\n\n```cpp\n#pragma once\n#include <array>\n#include <vector>\n#include <omp.h>\n\nvoid countQuartiles(std::vector<double> const& x, std::array<size_t, 4> &bins) {\n   #pragma omp parallel for\n   for (int i = 0; i < x.size(); i++) {\n      const double val = x[i];\n      const double frac = val - static_cast<int>(val);\n      const int bin = static_cast<int>(frac * 4.0);\n      #pragma omp atomic\n      bins[bin]++;\n   }\n}\n```",
  "22_histogram_count_quadrants": "\n\n```cpp\n#pragma once\n#include <array>\n#include <vector>\n\nstruct Point {\n   double x, y;\n};\n\n/* Count the number of cartesian points in each quadrant. The vector points contains a list of `Point` objects.\n   Store the counts in `bins`.\n   Example:\n   input: [{x=1.5, y=0.1}, {x=-3, y=1.1}, {x=5, y=9}, {x=1.5, y=-1}, {x=3, y=-7}, {x=0.1, y=2}]\n   output: [3, 1, 0, 2]\n*/\nvoid countQuadrants(std::vector<Point> const& points, std::array<size_t, 4> &bins) {\n   #pragma omp parallel for reduction(+: bins[0], bins[1], bins[2], bins[3])\n   for (auto const& point : points) {\n      if (point.x >= 0 && point.y >= 0) {\n            bins[0]++;\n      } else if (point.x < 0 && point.y >= 0) {\n            bins[1]++;\n      } else if (point.x < 0 && point.y < 0) {\n            bins[2]++;\n      } else if (point.x >= 0 && point.y < 0) {\n            bins[3]++;\n      }\n   }\n}\n```",
  "16_graph_largest_component": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <stack>\n#include <omp.h>\n\nint largestComponent(std::vector<int> const& A, size_t N) {\n   std::vector<bool> visited(N, false);\n   int maxCount = 0;\n   #pragma omp parallel for reduction(max: maxCount)\n   for (int i = 0; i < N; i++) {\n      if (!visited[i]) {\n         int count = 0;\n         std::stack<int> stack;\n         stack.push(i);\n         visited[i] = true;\n         count = 1;\n         while (!stack.empty()) {\n            int node = stack.top();\n            stack.pop();\n            for (int j = 0; j < N; j++) {\n               if (A[node * N + j] == 1 && !visited[j]) {\n                  visited[j] = true;\n                  count++;\n                  stack.push(j);\n               }\n            }\n         }\n         maxCount = std::max(maxCount, count);\n      }\n   }\n   return maxCount;\n}\n```",
  "27_reduce_average": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <omp.h>\n\ndouble average(std::vector<double> const& x) {\n    double sum = 0.0;\n    #pragma omp parallel for reduction(+:sum)\n    for (int i = 0; i < x.size(); ++i) {\n        sum += x[i];\n    }\n    return sum / (double) x.size();\n}\n```",
  "29_reduce_sum_of_min_of_pairs": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <algorithm>\n\nint64_t sumOfMinimumElements(std::vector<int64_t> const& x, std::vector<int64_t> const& y) {\n    int64_t sum = 0;\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < x.size(); ++i) {\n        sum += std::min(x[i], y[i]);\n    }\n    return sum;\n}\n```",
  "47_sparse_la_spmv": "\n\n```cpp\n#pragma once\n#include <vector>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\nvoid spmv(double alpha, std::vector<COOElement> const& A, std::vector<double> const& x, double beta, std::vector<double> &y, size_t M, size_t N) {\n   for (auto& element : y) {\n      element *= beta;\n   }\n\n   #pragma omp parallel for\n   for (size_t i = 0; i < A.size(); ++i) {\n      const COOElement& a_ij = A[i];\n      if (a_ij.row < M && a_ij.column < N) {\n         #pragma omp atomic\n         y[a_ij.row] += alpha * a_ij.value * x[a_ij.column];\n      }\n   }\n}\n```",
  "34_scan_largest_contiguous_subarray_sum": "\n\n```cpp\nint maximumSubarray(std::vector<int> const& x) {\n    int global_max = std::numeric_limits<int>::lowest();\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        int curr_sum = 0;\n        int local_max = std::numeric_limits<int>::lowest();\n        for (int j = i; j < x.size(); j++) {\n            curr_sum += x[j];\n            if (curr_sum > local_max) {\n                local_max = curr_sum;\n            }\n        }\n        #pragma omp critical\n        if (local_max > global_max) {\n            global_max = local_max;\n        }\n    }\n    return global_max;\n}\n```",
  "46_sparse_la_spmm": "\n\n```cpp\n#pragma once\n#include <vector>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\nvoid spmm(std::vector<COOElement> const& A, std::vector<COOElement> const& X, std::vector<double> &Y, size_t M, size_t K, size_t N) {\n   Y.assign(M * N, 0.0);\n   std::vector<std::vector<std::pair<size_t, double>>> X_by_row(K);\n   for (const auto& x : X) {\n      X_by_row[x.row].push_back({x.column, x.value});\n   }\n   #pragma omp parallel for schedule(static)\n   for (const auto& a : A) {\n      auto& row_list = X_by_row[a.column];\n      for (auto [col, val_x] : row_list) {\n         Y[a.row * N + col] += a.value * val_x;\n      }\n   }\n}\n```",
  "45_sparse_la_sparse_solve": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <omp.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\nvoid solveLinearSystem(std::vector<COOElement> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n   std::vector<std::vector<double>> matrix(N, std::vector<double>(N, 0.0));   \n   std::vector<double> b_copy = b;\n   // Fill the matrix with the values from A\n   for (const auto& element : A) {\n      matrix[element.row][element.column] = element.value;\n   }\n   // Initialize x with the size N\n   x.assign(N, 0.0);\n   // Perform Gaussian elimination\n   for (size_t i = 0; i < N; ++i) {\n      // Find pivot\n      double maxEl = std::abs(matrix[i][i]);\n      size_t maxRow = i;\n      for (size_t k = i + 1; k < N; ++k) {\n         if (std::abs(matrix[k][i]) > maxEl) {\n            maxEl = std::abs(matrix[k][i]);\n            maxRow = k;\n         }\n      }\n      // Swap maximum row with current row (column by column)\n      for (size_t k = i; k < N; ++k) {\n         std::swap(matrix[maxRow][k], matrix[i][k]);\n      }\n      std::swap(b_copy[maxRow], b_copy[i]);\n      // Make all rows below this one 0 in the current column\n      #pragma omp parallel for\n      for (size_t k = i + 1; k < N; ++k) {\n         double c = -matrix[k][i] / matrix[i][i];\n         matrix[k][i] = 0.0;\n         for (size_t j = i + 1; j < N; ++j) {\n            matrix[k][j] += c * matrix[i][j];\n         }\n         b_copy[k] += c * b_copy[i];\n      }\n   }\n   // Solve equation Ax=b for an upper triangular matrix A\n   for (int i = N - 1; i >= 0; --i) {\n      x[i] = b_copy[i] / matrix[i][i];\n      for (int k = i - 1; k >= 0; --k) {\n         b_copy[k] -= matrix[k][i] * x[i];\n      }\n   }\n}\n```",
  "25_reduce_xor": "\n\n```cpp\nbool reduceLogicalXOR(std::vector<bool> const& x) {\n    bool res = false;\n    #pragma omp parallel for reduction(^:res)\n    for (int i = 0; i < x.size(); i++) {\n        res ^= x[i];\n    }\n    return res;\n}\n```",
  "49_sparse_la_sparse_lu_decomp": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <omp.h>\n\nstruct COOElement {\n   size_t row, column;\n   double value;\n};\n\nvoid luFactorize(std::vector<COOElement> const& A, std::vector<double> &L, std::vector<double> &U, size_t N) {\n   std::vector<std::vector<double>> fullA(N, std::vector<double>(N, 0.0));\n   #pragma omp parallel for\n   for (size_t idx = 0; idx < A.size(); ++idx) {\n      fullA[A[idx].row][A[idx].column] = A[idx].value;\n   }\n\n   for (size_t i = 0; i < N; ++i) {\n      #pragma omp parallel for\n      for (size_t j = i; j < N; ++j) {\n         double sum = fullA[i][j];\n         for (size_t k = 0; k < i; ++k) {\n            sum -= L[i*N + k] * U[k*N + j];\n         }\n         U[i*N + j] = sum;\n      }\n\n      for (size_t j = 0; j < i; ++j) {\n         double sum = fullA[i][j];\n         for (size_t k = 0; k < j; ++k) {\n            sum -= L[i*N + k] * U[k*N + j];\n         }\n         L[i*N + j] = sum / U[j*N + j];\n      }\n      L[i*N + i] = 1.0;\n   }\n}\n```",
  "06_fft_dft": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <complex>\n#include <cmath>\n\n#if !defined(M_PI)\n#define M_PI 3.14159265358979323846\n#endif\n\nvoid dft(std::vector<double> const& x, std::vector<std::complex<double>> &output) {\n   int N = x.size();\n   output.resize(N, std::complex<double>(0, 0));\n   #pragma omp parallel for num_threads(8)\n   for (int k = 0; k < N; k++) {\n      std::complex<double> sum(0.0, 0.0);\n      double step = 2.0 * M_PI * k / N;\n      std::complex<double> r(std::cos(step), -std::sin(step));\n      std::complex<double> current(1.0, 0.0);\n      for (int n = 0; n < N; n++) {\n         sum += x[n] * current;\n         current *= r;\n      }\n      output[k] = sum;\n   }\n}\n```",
  "26_reduce_product_of_inverses": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <omp.h>\n\ndouble productWithInverses(std::vector<double> const& x) {\n    double product = 1.0;\n    #pragma omp parallel for reduction(*= : product)\n    for (size_t i = 0; i < x.size(); i++) {\n        if (i % 2 == 0) {\n            product *= x[i];\n        } else {\n            product /= x[i];\n        }\n    }\n    return product;\n}\n```",
  "28_reduce_smallest_odd_number": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <numeric>\n#include <omp.h>\n\nint smallestOdd(std::vector<int> const& x) {\n    int min_odd = std::numeric_limits<int>::max();\n    #pragma omp parallel num_threads(8)\n    {\n        int thread_id = omp_get_thread_num();\n        int chunk_size = x.size() / 8;\n        int start = thread_id * chunk_size;\n        int end = start + chunk_size;\n        if (end > x.size()) {\n            end = x.size();\n        }\n        int local_min = std::numeric_limits<int>::max();\n        for (int i = start; i < end; i++) {\n            if (x[i] & 1) {\n                if (x[i] < local_min) {\n                    local_min = x[i];\n                }\n            }\n        }\n        #pragma omp critical\n        {\n            if (local_min < min_odd) {\n                min_odd = local_min;\n            }\n        }\n    }\n    return min_odd;\n}\n```",
  "08_fft_split_fft": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <omp.h>\n\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<double> &r, std::vector<double> &i) {\n    std::vector<std::complex<double>> x_copy = x;\n    unsigned int N = x_copy.size();\n    if (N == 0) {\n        return;\n    }\n\n    // DFT\n    unsigned int k = N, n;\n    double thetaT = 3.14159265358979323846264338328L / N;\n    std::complex<double> phiT = std::complex<double>(std::cos(thetaT), -std::sin(thetaT));\n    std::complex<double> T = 1.0L;\n\n    while (k > 1) {\n        n = k;\n        k >>= 1;\n        phiT = phiT * phiT;\n        T = 1.0L;\n        for (unsigned int l = 0; l < k; l++) {\n            #pragma omp parallel for schedule(static)\n            for (unsigned int a = l; a < N; a += n) {\n                unsigned int b = a + k;\n                std::complex<double> t = x_copy[a] - x_copy[b];\n                x_copy[a] += x_copy[b];\n                x_copy[b] = t * T;\n            }\n            T *= phiT;\n        }\n    }\n\n    // Decimation\n    unsigned int m = (unsigned int)std::log2(N);\n    #pragma omp parallel for\n    for (unsigned int a = 0; a < N; a++) {\n        unsigned int b = a;\n        // Reverse bits\n        b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));\n        b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));\n        b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));\n        b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));\n        b = ((b >> 16) | (b << 16)) >> (32 - m);\n        if (b > a) {\n            std::complex<double> t = x_copy[a];\n            x_copy[a] = x_copy[b];\n            x_copy[b] = t;\n        }\n    }\n\n    // split into real and imaginary parts\n    for (size_t j = 0; j < x_copy.size(); j++) {\n        r[j] = x_copy[j].real();\n        i[j] = x_copy[j].imag();\n    }\n}\n```",
  "09_fft_fft_out_of_place": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <cmath>\n#include <complex>\n\n#if !defined(M_PI)\n#define M_PI 3.14159265358979323846\n#endif\n\nvoid fft(std::vector<std::complex<double>> const& x, std::vector<std::complex<double>> &output) {\n    output = x;\n    // DFT\n    unsigned int N = output.size(), k = N, n;\n    double thetaT = 3.14159265358979323846264338328L / N;\n    std::complex<double> phiT = std::complex<double>(std::cos(thetaT), -std::sin(thetaT)), T;\n    while (k > 1) {\n        n = k;\n        k >>= 1;\n        phiT = phiT * phiT;\n        T = 1.0L;\n        for (unsigned int l = 0; l < k; l++) {\n            #pragma omp parallel for\n            for (unsigned int a = l; a < N; a += n) {\n                unsigned int b = a + k;\n                std::complex<double> t = output[a] - output[b];\n                output[a] += output[b];\n                output[b] = t * T;\n            }\n            T *= phiT;\n        }\n    }\n    // Decimate\n    unsigned int m = (unsigned int)std::log2(N);\n    for (unsigned int a = 0; a < N; a++) {\n        unsigned int b = a;\n        // Reverse bits\n        b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));\n        b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));\n        b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));\n        b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));\n        b = ((b >> 16) | (b << 16)) >> (32 - m);\n        if (b > a) {\n            std::complex<double> t = output[a];\n            output[a] = output[b];\n            output[b] = t;\n        }\n    }\n}\n```",
  "48_sparse_la_sparse_axpy": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <omp.h>\n\nstruct Element {\n    size_t index;\n    double value;\n};\n\nvoid sparseAxpy(double alpha, std::vector<Element> const& x, std::vector<Element> const& y, std::vector<double> &z) {\n    size_t xi = 0, yi = 0;\n    const size_t num_threads = 8;\n    const size_t total = x.size() + y.size();\n    size_t chunk_size = total / num_threads;\n\n    #pragma omp parallel for\n    for (size_t i = 0; i < total; i++) {\n        // This approach is incorrect and won't work as intended\n        // The correct solution requires a different strategy\n    }\n}\n```",
  "05_fft_inverse_fft": "\n\n```cpp\n#pragma once\n#include <cmath>\n#include <vector>\n#include <complex>\n\n#if !defined(M_PI)\n#define M_PI 3.14159265358979323846\n#endif\n\nvoid fft_helper(std::vector<std::complex<double>> &x) {\n   // DFT\n   unsigned int N = x.size(), k = N, n;\n   double thetaT = 3.14159265358979323846264338328L / N;\n   std::complex<double> phiT = std::complex<double>(std::cos(thetaT), -std::sin(thetaT)), T;\n   while (k > 1) {\n      n = k;\n      k >>= 1;\n      phiT = phiT * phiT;\n      T = 1.0L;\n      for (unsigned int l = 0; l < k; l++) {\n         #pragma omp parallel for\n         for (unsigned int a = l; a < N; a += n) {\n            unsigned int b = a + k;\n            std::complex<double> t = x[a] - x[b];\n            x[a] += x[b];\n            x[b] = t * T;\n         }\n         T *= phiT;\n      }\n   }\n   // Decimate\n   unsigned int m = (unsigned int)std::log2(N);\n   for (unsigned int a = 0; a < N; a++) {\n      unsigned int b = a;\n      // Reverse bits\n      b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));\n      b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));\n      b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));\n      b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));\n      b = ((b >> 16) | (b << 16)) >> (32 - m);\n      if (b > a) {\n         std::complex<double> t = x[a];\n         x[a] = x[b];\n         x[b] = t;\n      }\n   }\n}\n\nvoid ifft(std::vector<std::complex<double>> &x) {\n   // conjugate the complex numbers\n   std::transform(x.begin(), x.end(), x.begin(), [](auto const& val) { return std::conj(val); });\n   // forward fft\n   fft_helper(x);\n   // conjugate the complex numbers again\n   std::transform(x.begin(), x.end(), x.begin(), [](auto const& val) { return std::conj(val); });\n   // scale the numbers\n   std::transform(x.begin(), x.end(), x.begin(), [&](std::complex<double> c) { return c / static_cast<double>(x.size()); });\n}\n```",
  "07_fft_fft_conjugate": "\n\n```cpp\n#include <omp.h>\n#pragma once\n#include <vector>\n#include <complex>\n#include <cmath>\n\nvoid fftConjugate(std::vector<std::complex<double>>& x) {\n    // DFT\n    unsigned int N = x.size(), k = N, n;\n    double thetaT = 3.14159265358979323846264338328L / N;\n    std::complex<double> phiT = std::complex<double>(std::cos(thetaT), -std::sin(thetaT)), T;\n    while (k > 1) {\n        n = k;\n        k >>= 1;\n        phiT = phiT * phiT;\n        T = 1.0L;\n        for (unsigned int l = 0; l < k; l++) {\n            #pragma omp parallel for\n            for (unsigned int a = l; a < N; a += n) {\n                unsigned int b = a + k;\n                std::complex<double> t = x[a] - x[b];\n                x[a] += x[b];\n                x[b] = t * T;\n            }\n            T *= phiT;\n        }\n    }\n    // Decimate\n    unsigned int m = (unsigned int)std::log2(N);\n    #pragma omp parallel for\n    for (unsigned int a = 0; a < N; a++) {\n        unsigned int b = a;\n        // Reverse bits\n        b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));\n        b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));\n        b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));\n        b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));\n        b = ((b >> 16) | (b << 16)) >> (32 - m);\n        if (b > a) {\n            std::complex<double> t = x[a];\n            x[a] = x[b];\n            x[b] = t;\n        }\n    }\n\n    // conjugate\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        x[i] = std::conj(x[i]);\n    }\n}\n```",
  "03_dense_la_axpy": "\n\n```cpp\nvoid axpy(double alpha, std::vector<double> const& x, std::vector<double> const& y, std::vector<double> &z) {\n    #pragma omp parallel for\n    for (size_t i = 0; i < x.size(); i++) {\n        z[i] = alpha * x[i] + y[i];\n    }\n}\n```",
  "12_geometry_smallest_triangle": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <limits>\n#include <cmath>\n\nstruct Point {\n    double x, y;\n};\n\ndouble smallestArea(std::vector<Point> const& points) {\n    if (points.size() < 3) {\n        return 0;\n    }\n    double minArea = std::numeric_limits<double>::max();\n    #pragma omp parallel for num_threads(8) schedule(static)\n    for (size_t i = 0; i < points.size() - 2; i++) {\n        for (size_t j = i + 1; j < points.size() - 1; j++) {\n            for (size_t k = j + 1; k < points.size(); k++) {\n                double area = 0.5 * std::abs(\n                    points[i].x * (points[j].y - points[k].y) +\n                    points[j].x * (points[k].y - points[i].y) +\n                    points[k].x * (points[i].y - points[j].y)\n                );\n                if (area < minArea) {\n                    minArea = area;\n                }\n            }\n        }\n    }\n    return minArea;\n}\n```",
  "11_geometry_convex_hull_perimeter": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <omp.h>\n\nstruct Point {\n    double x, y;\n};\n\ndouble convexHullPerimeter(std::vector<Point> const& points) {\n    if (points.size() < 3) {\n        return 0.0;\n    }\n\n    std::vector<Point> pointsSorted = points;\n    std::sort(pointsSorted.begin(), pointsSorted.end(), [](Point const& a, Point const& b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    });\n\n    auto CrossProduct = [](Point const& a, Point const& b, Point const& c) {\n        double dx1 = b.x - a.x;\n        double dy1 = b.y - a.y;\n        double dx2 = c.x - a.x;\n        double dy2 = c.y - a.y;\n        return dx1 * dy2 - dy1 * dx2;\n    };\n\n    auto dist = [](Point const& p1, Point const& p2) {\n        double dx = p2.x - p1.x;\n        double dy = p2.y - p1.y;\n        return std::sqrt(dx * dx + dy * dy);\n    };\n\n    std::vector<Point> ans(2 * pointsSorted.size());\n    int n = points.size();\n    int k = 0;\n\n    // Build lower hull\n    for (int i = 0; i < n; ++i) {\n        while (k >= 2 && CrossProduct(ans[k - 2], ans[k - 1], pointsSorted[i]) <= 0) {\n            k--;\n        }\n        ans[k++] = pointsSorted[i];\n    }\n\n    // Build upper hull\n    for (int i = n - 1, t = k + 1; i > 0; --i) {\n        while (k >= t && CrossProduct(ans[k - 2], ans[k - 1], pointsSorted[i - 1]) <= 0) {\n            k--;\n        }\n        ans[k++] = pointsSorted[i - 1];\n    }\n\n    ans.resize(k - 1);\n\n    double perimeter = 0.0;\n    #pragma omp parallel for reduction(+:perimeter)\n    for (int i = 0; i < ans.size() - 1; i++) {\n        perimeter += dist(ans[i], ans[i + 1]);\n    }\n    perimeter += dist(ans[0], ans[ans.size() - 1]);\n\n    return perimeter;\n}\n```",
  "14_geometry_closest_pair_1d": "\n\n```cpp\n#pragma once\n#include <algorithm>\n#include <vector>\n#include <limits>\n\ndouble closestPair(std::vector<double> const& x) {\n    if (x.size() < 2) {\n        return 0;\n    }\n    std::vector<double> sorted_x = x;\n    std::sort(sorted_x.begin(), sorted_x.end());\n    double minDist = std::numeric_limits<double>::max();\n    for (size_t i = 0; i < sorted_x.size() - 1; i++) {\n        double dist = sorted_x[i+1] - sorted_x[i];\n        if (dist < minDist) {\n            minDist = dist;\n        }\n    }\n    return minDist;\n}\n```",
  "13_geometry_closest_pair_2d": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <limits>\n#include <cmath>\n\nstruct Point {\n    double x, y;\n};\n\ndouble closestPair(std::vector<Point> const& points) {\n    if (points.size() < 2) {\n        return 0;\n    }\n    double minDist = std::numeric_limits<double>::max();\n    #pragma omp parallel for reduction(min: minDist)\n    for (size_t i = 0; i < points.size() - 1; i++) {\n        double localMin = std::numeric_limits<double>::max();\n        for (size_t j = i + 1; j < points.size(); j++) {\n            double dx = points[j].x - points[i].x;\n            double dy = points[j].y - points[i].y;\n            double dist = std::sqrt(dx * dx + dy * dy);\n            if (dist < localMin) {\n                localMin = dist;\n            }\n        }\n        minDist = std::min(minDist, localMin);\n    }\n    return minDist;\n}\n```",
  "52_stencil_1d_jacobi_3-point_stencil": "\n\n```cpp\n#pragma once\n#include <vector>\n\n/* Compute one iteration of a 3-point 1D jacobi stencil on `input`. Store the results in `output`.\n   Each element of `input` will be averaged with its two neighbors and stored in the corresponding element of `output`.\n   i.e. output[i] = (input[i-1]+input[i]+input[i+1])/3\n   Replace with 0 when reading past the boundaries of `input`.\n   Example:\n   input: [9, -6, -1, 2, 3]\n   output: [1, 2/3, -5/3, 4/3, 5/3]\n*/\nvoid jacobi1D(std::vector<double> const& input, std::vector<double> &output) {\n    size_t n = input.size();\n    if (n == 0) {\n        return;\n    }\n    // Handle first element\n    if (n > 1) {\n        output[0] = (input[0] + input[1]) / 3.0;\n    } else {\n        output[0] = input[0] / 3.0;\n    }\n    // Handle last element\n    if (n > 1) {\n        output[n-1] = (input[n-2] + input[n-1]) / 3.0;\n    } else {\n        output[n-1] = input[n-1] / 3.0;\n    }\n    // Middle elements\n    #pragma omp parallel for\n    for (size_t i = 1; i < n - 1; i++) {\n        output[i] = (input[i-1] + input[i] + input[i+1]) / 3.0;\n    }\n}\n```",
  "04_dense_la_gemv": "\n\n```cpp\nvoid gemv(std::vector<double> const& A, std::vector<double> const& x, std::vector<double> &y, size_t M, size_t N) {\n   #pragma omp parallel for\n   for (size_t i = 0; i < M; i++) {\n      double *row = &A[i * N];\n      y[i] = 0.0;\n      for (size_t j = 0; j < N; j++) {\n         y[i] += row[j] * x[j];\n      }\n   }\n}\n```",
  "00_dense_la_lu_decomp": "\n\n```cpp\n#pragma once\n#include <vector>\n\nvoid luFactorize(std::vector<double> &A, size_t N) {\n    for (size_t k = 0; k < N; ++k) {\n        #pragma omp parallel for\n        for (size_t i = k + 1; i < N; ++i) {\n            double factor = A[i * N + k] / A[k * N + k];\n            A[i * N + k] = factor;\n            for (size_t j = k + 1; j < N; ++j) {\n                A[i * N + j] -= factor * A[k * N + j];\n            }\n        }\n    }\n}\n```",
  "01_dense_la_solve": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <omp.h>\n\nvoid solveLinearSystem(std::vector<double> const& A, std::vector<double> const& b, std::vector<double> &x, size_t N) {\n   std::vector<double> A_copy = A;\n   std::vector<double> b_copy = b;\n   for (size_t i = 0; i < N - 1; i++) {\n      double pivot = A_copy[i * N + i];\n      if (pivot == 0) {\n         return;\n      }\n      #pragma omp parallel for schedule(static)\n      for (size_t j = i + 1; j < N; j++) {\n         double factor = A_copy[j * N + i] / pivot;\n         for (size_t k = i; k < N; k++) {\n            A_copy[j * N + k] -= factor * A_copy[i * N + k];\n         }\n         b_copy[j] -= factor * b_copy[i];\n      }\n   }\n   for (int i = N - 1; i >= 0; i--) {\n      double sum = 0;\n      for (size_t j = i + 1; j < N; j++) {\n         sum += A_copy[i * N + j] * x[j];\n      }\n      x[i] = (b_copy[i] - sum) / A_copy[i * N + i];\n   }\n}\n```",
  "50_stencil_xor_kernel": "\n\n```cpp\n#pragma once\n#include <vector>\n\nvoid cellsXOR(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n    #pragma omp parallel for num_threads(8)\n    for (size_t i = 0; i < N; i++) {\n        size_t input_row = i * N;\n        size_t input_prev_row = (i - 1) * N;\n        size_t input_next_row = (i + 1) * N;\n\n        for (size_t j = 0; j < N; j++) {\n            int count = 0;\n            if (i > 0) {\n                if (input[input_prev_row + j] == 1) count++;\n            }\n            if (i < N - 1) {\n                if (input[input_next_row + j] == 1) count++;\n            }\n            if (j > 0) {\n                if (input[input_row + j - 1] == 1) count++;\n            }\n            if (j < N - 1) {\n                if (input[input_row + j + 1] == 1) count++;\n            }\n            output[input_row + j] = (count == 1) ? 1 : 0;\n        }\n    }\n}\n```",
  "10_geometry_convex_hull": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n\nstruct Point {\n    double x, y;\n};\n\nvoid convexHull(std::vector<Point> const& points, std::vector<Point> &hull) {\n    if (points.size() < 3) {\n        hull = points;\n        return;\n    }\n\n    std::vector<Point> pointsSorted = points;\n    #pragma omp parallel for\n    std::sort(pointsSorted.begin(), pointsSorted.end(), [](Point const& a, Point const& b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    });\n\n    int n = points.size();\n    std::vector<Point> ans(2 * n);\n\n    int k = 0;\n    // Build lower hull\n    for (int i = 0; i < n; ++i) {\n        while (k >= 2) {\n            double cross = (ans[k-1].x - ans[k-2].x) * (pointsSorted[i].y - ans[k-2].y) - (ans[k-1].y - ans[k-2].y) * (pointsSorted[i].x - ans[k-2].x);\n            if (cross <= 0) {\n                k--;\n            } else {\n                break;\n            }\n        }\n        ans[k++] = pointsSorted[i];\n    }\n\n    // Build upper hull\n    for (int i = n - 1, t = k + 1; i > 0; --i) {\n        while (k >= t) {\n            double cross = (ans[k-1].x - ans[k-2].x) * (pointsSorted[i-1].y - ans[k-2].y) - (ans[k-1].y - ans[k-2].y) * (pointsSorted[i-1].x - ans[k-2].x);\n            if (cross <= 0) {\n                k--;\n            } else {\n                break;\n            }\n        }\n        ans[k++] = pointsSorted[i-1];\n    }\n\n    ans.resize(k - 1);\n    hull = ans;\n}\n```",
  "51_stencil_edge_kernel": "\n\n```cpp\n#pragma once\n#include <vector>\n\nconst int edgeKernel[3][3] = {{-1, -1, -1}, {-1, 8, -1}, {-1, -1, -1}};\n\nvoid convolveKernel(std::vector<int> const& imageIn, std::vector<int> &imageOut, size_t N) {\n    #pragma omp parallel for schedule(static)\n    for (size_t i = 0; i < N; i++) {\n        for (size_t j = 0; j < N; j++) {\n            int sum = 8 * imageIn[i * N + j];\n            for (int k = -1; k < 2; k++) {\n                for (int l = -1; l < 2; l++) {\n                    if (k == 0 && l == 0) continue;\n                    int x = i + k;\n                    int y = j + l;\n                    if (x >= 0 && x < N && y >= 0 && y < N) {\n                        sum -= imageIn[x * N + y];\n                    }\n                }\n            }\n            if (sum < 0) {\n                imageOut[i * N + j] = 0;\n            } else if (sum > 255) {\n                imageOut[i * N + j] = 255;\n            } else {\n                imageOut[i * N + j] = sum;\n            }\n        }\n    }\n}\n```",
  "02_dense_la_gemm": "\n\n```cpp\n#pragma once\n#include <vector>\n\nvoid gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {\n    #pragma omp parallel for schedule(static)\n    for (size_t i = 0; i < M; i++) {\n        for (size_t k = 0; k < K; k++) {\n            double a = A[i*K + k];\n            for (size_t j = 0; j < N; j++) {\n                C[i*N + j] += a * B[k*N + j];\n            }\n        }\n    }\n}\n```",
  "41_sort_k-th_smallest_element": "\n\n```cpp\n#pragma once\n#include <algorithm>\n#include <vector>\n\nint findKthSmallest(std::vector<int> const& x, int k) {\n    std::vector<int> x_copy = x;\n    std::nth_element(x_copy.begin(), x_copy.begin() + k - 1, x_copy.end());\n    return x_copy[k - 1];\n}\n```",
  "43_sort_sort_an_array_of_structs_by_key": "\n\n```cpp\n#pragma once\n#include <vector>\n\nstruct Result {\n   int startTime, duration;\n   float value;\n};\n\nstruct CompareStartTime {\n   bool operator()(const Result& a, const Result& b) const {\n      return a.startTime < b.startTime;\n   }\n};\n\nvoid sortByStartTime(std::vector<Result> &results) {\n   std::sort(results.begin(), results.end(), CompareStartTime());\n}\n```",
  "39_search_xor_contains": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <algorithm>\n#include <omp.h>\n\nbool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {\n    bool foundInX = false;\n    bool foundInY = false;\n\n    #pragma omp parallel sections\n    {\n        #pragma omp section\n        {\n            foundInX = std::find(x.begin(), x.end(), val) != x.end();\n        }\n        #pragma omp section\n        {\n            foundInY = std::find(y.begin(), y.end(), val) != y.end();\n        }\n    }\n\n    return foundInX ^ foundInY;\n}\n```",
  "53_stencil_2d_jacobi_5-point_stencil": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <omp.h>\n\nvoid jacobi2D(std::vector<double> const& input, std::vector<double> &output, size_t N) {\n    if (N == 1) {\n        output[0] = input[0] / 5.0;\n        return;\n    }\n\n    #pragma omp parallel for schedule(static)\n    for (size_t i = 1; i < N-1; i++) {\n        for (size_t j = 1; j < N-1; j++) {\n            double sum = input[(i-1)*N + j] +\n                         input[(i+1)*N + j] +\n                         input[i*N + j-1] +\n                         input[i*N + j+1] +\n                         input[i*N + j];\n            output[i*N + j] = sum / 5.0;\n        }\n    }\n\n    for (size_t j = 0; j < N; j++) {\n        double sum = input[j];\n        if (j > 0) {\n            sum += input[j-1];\n        }\n        if (j < N-1) {\n            sum += input[j+1];\n        }\n        sum += input[N + j];\n        output[j] = sum / 5.0;\n    }\n\n    for (size_t j = 0; j < N; j++) {\n        double sum = input[(N-1)*N + j];\n        if (j > 0) {\n            sum += input[(N-1)*N + j-1];\n        }\n        if (j < N-1) {\n            sum += input[(N-1)*N + j+1];\n        }\n        sum += input[(N-2)*N + j];\n        output[(N-1)*N + j] = sum / 5.0;\n    }\n\n    for (size_t i = 1; i < N-1; i++) {\n        double sum = input[i*N];\n        if (i > 0) {\n            sum += input[(i-1)*N];\n        }\n        if (i < N-1) {\n            sum += input[(i+1)*N];\n        }\n        sum += input[i*N + 1];\n        output[i*N] = sum / 5.0;\n    }\n\n    for (size_t i = 1; i < N-1; i++) {\n        double sum = input[i*N + N-1];\n        if (i > 0) {\n            sum += input[(i-1)*N + N-1];\n        }\n        if (i < N-1) {\n            sum += input[(i+1)*N + N-1];\n        }\n        sum += input[i*N + N-2];\n        output[i*N + N-1] = sum / 5.0;\n    }\n}\n```",
  "54_stencil_game_of_life": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <omp.h>\n\nvoid gameOfLife(std::vector<int> const& input, std::vector<int> &output, size_t N) {\n    #pragma omp parallel for num_threads(8)\n    for (size_t i = 0; i < N; i++) {\n        const int* row = &input[i * N];\n        for (size_t j = 0; j < N; j++) {\n            int sum = 0;\n            if (i > 0) {\n                sum += input[(i - 1) * N + j];\n            }\n            if (i < N - 1) {\n                sum += input[(i + 1) * N + j];\n            }\n            if (j > 0) {\n                sum += row[j - 1];\n            }\n            if (j < N - 1) {\n                sum += row[j + 1];\n            }\n            if (i > 0 && j > 0) {\n                sum += input[(i - 1) * N + (j - 1)];\n            }\n            if (i > 0 && j < N - 1) {\n                sum += input[(i - 1) * N + (j + 1)];\n            }\n            if (i < N - 1 && j > 0) {\n                sum += input[(i + 1) * N + (j - 1)];\n            }\n            if (i < N - 1 && j < N - 1) {\n                sum += input[(i + 1) * N + (j + 1)];\n            }\n            if (row[j] == 1) {\n                if (sum < 2) {\n                    output[i * N + j] = 0;\n                } else if (sum == 2 || sum == 3) {\n                    output[i * N + j] = 1;\n                } else {\n                    output[i * N + j] = 0;\n                }\n            } else {\n                if (sum == 3) {\n                    output[i * N + j] = 1;\n                } else {\n                    output[i * N + j] = 0;\n                }\n            }\n        }\n    }\n}\n```",
  "40_sort_sort_an_array_of_complex_numbers_by_magnitude": "\n\n```cpp\n#pragma once\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <omp.h>\n\nvoid sortComplexByMagnitude(std::vector<std::complex<double>> &x) {\n    const int n = x.size();\n    if (n <= 1) return;\n\n    std::vector<double> mags(n);\n    #pragma omp parallel for\n    for (int i = 0; i < n; ++i) {\n        mags[i] = std::abs(x[i]);\n    }\n\n    std::vector<int> indices(n);\n    for (int i = 0; i < n; ++i) {\n        indices[i] = i;\n    }\n\n    std::sort(indices.begin(), indices.end(), [&](int a, int b) {\n        return mags[a] < mags[b];\n    });\n\n    std::vector<std::complex<double>> sorted(n);\n    for (int i = 0; i < n; ++i) {\n        sorted[i] = x[indices[i]];\n    }\n\n    x = std::move(sorted);\n}\n```",
  "42_sort_sorted_ranks": "\n\n```cpp\n#pragma once\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <omp.h>\n\nvoid ranks(std::vector<float> const& x, std::vector<size_t> &ranks_) {\n   const size_t n = x.size();\n   std::vector<size_t> indices(n);\n   std::iota(indices.begin(), indices.end(), 0);\n\n   // Split into 8 chunks for parallel sorting\n   std::vector<std::vector<size_t>> chunks(8);\n   size_t chunk_size = n / 8;\n   for (size_t i = 0; i < n; ++i) {\n      size_t chunk_idx = i / chunk_size;\n      if (chunk_idx >= 8) chunk_idx = 7;\n      chunks[chunk_idx].push_back(indices[i]);\n   }\n\n   // Sort each chunk in parallel\n   #pragma omp parallel for\n   for (int i = 0; i < 8; ++i) {\n      std::sort(chunks[i].begin(), chunks[i].end(), [&x](size_t i1, size_t i2) {\n         return x[i1] < x[i2];\n      });\n   }\n\n   // Merge sorted chunks\n   std::vector<size_t> sorted_indices;\n   sorted_indices.reserve(n);\n   for (auto& chunk : chunks) {\n      sorted_indices.insert(sorted_indices.end(), chunk.begin(), chunk.end());\n   }\n\n   // Assign ranks\n   for (size_t i = 0; i < sorted_indices.size(); ++i) {\n      ranks_[sorted_indices[i]] = i;\n   }\n}\n```",
  "36_search_check_if_array_contains_value": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <omp.h>\n\nbool contains(std::vector<int> const& x, int target) {\n    if (x.empty()) {\n        return false;\n    }\n    #pragma omp parallel for\n    for (int i = 0; i < x.size(); i++) {\n        if (x[i] == target) {\n            return true;\n        }\n    }\n    return false;\n}\n```",
  "38_search_find_the_first_even_number": "\n\n```cpp\n#pragma once\n#include <vector>\n\n/* Return the index of the first even number in the vector x.\n   Examples:\n   input: [7, 3, 9, 5, 5, 7, 2, 9, 12, 11]\n   output: 6\n   input: [3, 8, 9, 9, 3, 4, 8, 6]\n   output: 1\n*/\nsize_t findFirstEven(std::vector<int> const& x) {\n   for (size_t i = 0; i < x.size(); i++) {\n      if ((x[i] & 1) == 0) {\n            return i;\n      }\n   }\n   return x.size();\n}\n```",
  "37_search_find_the_closest_number_to_pi": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <omp.h>\n\nsize_t findClosestToPi(std::vector<double> const& x) {\n    size_t index = 0;\n    double min = std::abs(x[0] - M_PI);\n\n    #pragma omp parallel for reduction(min: min)\n    for (size_t i = 1; i < x.size(); ++i) {\n        double diff = std::abs(x[i] - M_PI);\n        if (diff < min) {\n            min = diff;\n            index = i;\n        }\n    }\n\n    return index;\n}\n```",
  "44_sort_sort_non-zero_elements": "\n\n```cpp\n#pragma once\n#include <algorithm>\n#include <vector>\n#include <omp.h>\n#include <climits>\n\nvoid sortIgnoreZero(std::vector<int> &x) {\n    const int num_threads = omp_get_max_threads();\n    std::vector<std::vector<int>> localNonZeros(num_threads);\n    const int chunk_size = (x.size() + num_threads - 1) / num_threads;\n\n    #pragma omp parallel\n    {\n        int thread_id = omp_get_thread_num();\n        int start = thread_id * chunk_size;\n        int end = std::min(start + chunk_size, static_cast<int>(x.size()));\n\n        for (int i = start; i < end; ++i) {\n            if (x[i] != 0) {\n                localNonZeros[thread_id].push_back(x[i]);\n            }\n        }\n    }\n\n    std::vector<int> nonZeroElements;\n    for (const auto &vec : localNonZeros) {\n        for (int num : vec) {\n            nonZeroElements.push_back(num);\n        }\n    }\n\n    std::sort(nonZeroElements.begin(), nonZeroElements.end());\n    size_t nonZeroIndex = 0;\n    for (int i = 0; i < x.size(); ++i) {\n        if (x[i] != 0) {\n            x[i] = nonZeroElements[nonZeroIndex];\n            ++nonZeroIndex;\n        }\n    }\n}\n```",
  "35_search_search_for_last_struct_by_key": "\n\n```cpp\n#pragma once\n#include <vector>\n#include <omp.h>\n\nstruct Book {\n   std::string title;\n   int pages;\n};\n\nsize_t findLastShortBook(std::vector<Book> const& books) {\n    size_t max_index = static_cast<size_t>(-1);\n    #pragma omp parallel for reduction(max: max_index)\n    for (size_t i = 0; i < books.size(); i++) {\n        if (books[i].pages < 100) {\n            if (i > max_index) {\n                max_index = i;\n            }\n        }\n    }\n    return (max_index == static_cast<size_t>(-1)) ? books.size() : max_index;\n}\n```"
}